<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dong1iu.github.io</id>
    <title>动动栋栋</title>
    <updated>2021-09-13T03:18:25.361Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dong1iu.github.io"/>
    <link rel="self" href="https://dong1iu.github.io/atom.xml"/>
    <subtitle>南风知我意 吹梦到西洲</subtitle>
    <logo>https://dong1iu.github.io/images/avatar.png</logo>
    <icon>https://dong1iu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 动动栋栋</rights>
    <entry>
        <title type="html"><![CDATA[MySQL快速入门]]></title>
        <id>https://dong1iu.github.io/post/mysql-kuai-su-ru-men/</id>
        <link href="https://dong1iu.github.io/post/mysql-kuai-su-ru-men/">
        </link>
        <updated>2021-06-17T01:39:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-入门">一、入门</h1>
<h2 id="一一些词汇">（一）一些词汇</h2>
<p>schema 模式 → 关于数据库和表的布局及特性的信息</p>
<p>datetype → 数据类型</p>
<p>column</p>
<p>row</p>
<p>primary key → 主键作为唯一标识，不得重复，非空</p>
<h2 id="二主键和sql语句">（二）主键和SQL语句</h2>
<p>主键的习惯</p>
<ol>
<li>不更改主键列的值</li>
<li>不重用主键的值</li>
<li>不在主键中使用可能会更改的值</li>
</ol>
<p>什么是SQL</p>
<p>SQL是数据库查询语言</p>
<h1 id="二-数据库的基本操作">二、数据库的基本操作</h1>
<h2 id="选择数据库">选择数据库</h2>
<p>语句： <code>use db;</code></p>
<p>返回值：无</p>
<h2 id="查看有哪些数据库">查看有哪些数据库</h2>
<p>语句：<code>show databases;</code></p>
<p>返回值：返回可用数据库的一个列表</p>
<h2 id="查看有哪些表">查看有哪些表</h2>
<p>语句：<code>show tables;</code></p>
<p>返回值：返回可用表的一个列表</p>
<h2 id="其他常用的语句">其他常用的语句</h2>
<ul>
<li><code>SHOW STATUS</code>，用于显示广泛的服务器状态信息;</li>
<li><code>SHOW CREATE DATABASE</code>和<code>SHOW CREATE TABLE</code>，分别用来显示创建特定数据库或表的MySQL语句;</li>
<li><code>SHOW GRANTS</code>，用来显示授予用户(所有用户或特定用户)的安全权限;</li>
<li><code>SHOW ERRORS</code>和<code>SHOW WARNINGS</code>，用来显示服务器错误或警告消息。</li>
</ul>
<h2 id="常见的关键词">常见的关键词</h2>
<p><code>DISTINCT</code>：去重</p>
<h1 id="三-排序">三、排序</h1>
<h2 id="单排序">单排序</h2>
<p><code>select * from student order by age;</code></p>
<h2 id="多排序">多排序</h2>
<p><code>select * from student order by age, major;</code></p>
<h2 id="升序和将序">升序和将序</h2>
<p><code>ORDER BY col1 DESC, col2</code></p>
<p>默认升序ASC，DESC降序</p>
<h2 id="注意">注意</h2>
<p>order by 不能处理A和a的排序问题，这个问题取决于数据库系统本身的设置</p>
<h1 id="四-数据过滤">四、数据过滤</h1>
<h2 id="where子句">WHERE子句</h2>
<p>常见操作符</p>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623897403344.png" alt="" loading="lazy"></figure>
<p>注意：</p>
<ol>
<li><strong>MySQL在执行匹配时默认不区分大小写</strong></li>
<li><code>BETWEEN AND</code> 两边都是闭区间</li>
<li>空值检查 → <code>IS NULL</code></li>
</ol>
<h2 id="操作符">操作符</h2>
<p>AND 操作符</p>
<p><code>WHERE ... AND WHERE ...</code></p>
<p>OR 操作符</p>
<p><code>WHERE ... OR WHERE ...</code></p>
<p>IN操作符</p>
<p><code>WHERE ... IN (1001, 1002)</code></p>
<p><code>IN</code>和<code>OR</code>的区别</p>
<p>其实<code>IN</code>操作符和<code>OR</code>完成的功能是一样的，但是<code>IN</code>操作符1.在语法上更简单、2.速度上更快、3.而且可以嵌套新的查询语句</p>
<p>NOT操作符</p>
<p>取反</p>
<h1 id="五-通配符">五、通配符</h1>
<h2 id="like操作符"><code>LIKE</code>操作符</h2>
<p>两个名词：通配符(wildcard)和搜索模式(search pattern)</p>
<p>search pattern一般由字面量和通配符组成</p>
<h2 id="常用的通配符">常用的通配符</h2>
<p><code>%</code> : 任意字符包括不匹配，<strong>但是注意%不能匹配NULL</strong></p>
<p><code>_</code> : 一个字符</p>
<h2 id="使用注意">使用注意</h2>
<ol>
<li>不要过度使用通配符，会导致查询的速度很慢</li>
<li>尽量不要将通配符放在匹配模式的前面，同样会导致速度相对变慢</li>
<li>注意不要错</li>
</ol>
<h1 id="六-正则表达式">六、正则表达式</h1>
<p>MySQL的正则表达式是通用的</p>
<h2 id="regexp关键字"><code>REGEXP</code>关键字</h2>
<pre><code class="language-sql">
SELECT * FROM student where item REGEXP '1000'
</code></pre>
<h2 id="or">OR</h2>
<p><code>REGEXP '1000|2000'</code></p>
<h2 id="转义">转义</h2>
<p>匹配一些特殊字符时，要在前面加<code>\\</code>，因为<code>\本身</code>也是特殊字符</p>
<p>比如匹配<code>.</code>，需要使用<code>\\.</code></p>
<h2 id="空白字符">空白字符</h2>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623897415622.png" alt="" loading="lazy"></figure>
<h2 id="匹配字符类">匹配字符类</h2>
<figure data-type="image" tabindex="3"><img src="https://dong1iu.github.io/post-images/1623897423942.png" alt="" loading="lazy"></figure>
<h2 id="匹配多个实体">匹配多个实体</h2>
<p>一个字符中可能有多个匹配的位置</p>
<p><a href="https://www.notion.so/48c62af6d57241beb93e01eec2d89564">重复元字符</a></p>
<h2 id="定位符">定位符</h2>
<p><a href="https://www.notion.so/9af2cc31b7ae477795ae854bb0fbae22">定位符表</a></p>
<p>例子</p>
<pre><code class="language-sql">SELECT * FROM student WHERE major REGEXP '^math'
</code></pre>
<h1 id="七-计算字段">七、计算字段</h1>
<h2 id="什么是计算字段">什么是计算字段</h2>
<p>在<code>SELECT</code>语句查询时计算的字段称为计算字段</p>
<p>字段（field）和列（column）是同一个意思</p>
<p>注意</p>
<p><strong>数据库服务器是知道<code>SELECT</code>语句中的字段是原生的字段，还是计算产生的字段</strong></p>
<h2 id="拼接字段">拼接字段</h2>
<p><code>Concat</code>函数</p>
<p>语法：CONCAT(field1, field2, ...)</p>
<p>RTrim函数</p>
<p>语法：RTrim(field)</p>
<p>含义：删除右边的空格</p>
<p>使用别名</p>
<p><code>AS</code>关键字</p>
<h2 id="执行计算">执行计算</h2>
<p><code>SELCET</code>时计算，如<code>SELECT order_id, price*amount AS expanded_price;</code></p>
<p>SQL支持<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></p>
<h1 id="八-数据处理函数">八、数据处理函数</h1>
<h2 id="文本处理函数">文本处理函数</h2>
<p>RTrim()</p>
<p>Upper()等</p>
<figure data-type="image" tabindex="4"><img src="https://dong1iu.github.io/post-images/1623897466003.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://dong1iu.github.io/post-images/1623897473866.png" alt="" loading="lazy"></figure>
<p>locate</p>
<p>语法：<code>locate(substr,str)</code></p>
<p>含义:返回子串 substr 在字符串 str 中第一次出现的位置</p>
<h2 id="日期处理">日期处理</h2>
<h3 id="1-日期格式">1. 日期格式</h3>
<p><a href="https://www.notion.so/e9a4a6a862964a028b63d4afab4bcbd7">MySQL中的日期格式</a></p>
<h3 id="2-时间处理">2. 时间处理</h3>
<p><a href="https://www.notion.so/072bfdba88cf454caeef87114be5e6f0">时间处理函数</a></p>
<h3 id="3间隔-interval">3.间隔 <code>INTERVAL</code></h3>
<p>语法：<code>INTERVAL expr unit</code></p>
<p>间隔值也用于各种时间函数，如<code>DATE_ADD</code>，<code>DATE_SUB</code>，<code>TIMESTAMPADD</code>和<code>TIMESTAMPDIFF</code></p>
<p>常用的使用</p>
<pre><code class="language-sql">set @dt=str_to_date('2021-6-10', '%Y-%m-%d');
select @dt - interval 1 day; # 返回2021-6-9
select @dt - interval 1 hour;
select @dt - interval 1 second;

# 复合
select @dt - interval '1 00:00:00' DAY_SECOND; # 返回2021-6-9
</code></pre>
<ul>
<li>
<p>完整的表格</p>
<p><a href="https://www.notion.so/99e78f03689843e1adfa606798ec5e14">interval可选unit</a></p>
</li>
</ul>
<h3 id="4-标准化">4. 标准化</h3>
<p><code>'2020-01-01 00:00:00'</code>→<code>'%Y-%m-%d %H:%i:%S'</code></p>
<h1 id="九-汇总数据">九、汇总数据</h1>
<h2 id="聚集函数">聚集函数</h2>
<p><code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>COUNT()</code>、<code>SUM()</code></p>
<h2 id="聚集不同的值">聚集不同的值</h2>
<p><code>SELECT AVG(DISTINCT salary) FROM emp;</code></p>
<h2 id="组合聚集数">组合聚集数</h2>
<pre><code class="language-sql">
SELECT COUNT(*) AS num_items,
	MIN(prod_price) as price_min,
	MAX(prod_price) as price_max
FROM products
</code></pre>
<h1 id="十-分组">十、分组</h1>
<h2 id="创建分组">创建分组</h2>
<p>关键字<code>GROUP BY</code></p>
<p>注意</p>
<ol>
<li><strong>除了聚集语句外</strong>，SELECT语句中的所有列必须出现在GROUP BY子句中</li>
<li>如果<strong>分组列中具有NULL值</strong>，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组</li>
<li><strong>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</strong></li>
</ol>
<p>例子</p>
<pre><code class="language-sql">SELECT
	departmentId,
	avg( salary ) 
FROM
	employee 
GROUP BY
	departmentId
ORDER BY
	departmentId;
</code></pre>
<h2 id="过滤数据">过滤数据</h2>
<p>使用<code>HAVING</code>过滤分组</p>
<p>例子</p>
<pre><code class="language-sql">SELECT
	departmentId,
	avg( salary ) 
FROM
	employee 
GROUP BY
	departmentId 
HAVING
	avg( salary )&gt; 2000 
ORDER BY
	departmentId;
</code></pre>
<p><code>HAVING</code>和<code>WHERE</code>的区别</p>
<p><code>Where</code> 是一个约束声明，使用Where来约束来自数据库的数据，<code>Where</code>是在结果返回之前起作用的，且<code>Where</code>中不能使用聚合函数。</p>
<p><code>Having</code>是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在<code>Having</code>中可以使用聚合函数。</p>
<p>在执行顺序上的不同</p>
<p>要明白这一点，我们要明白SQL语句的执行顺序</p>
<pre><code>(8)SELECT (9)DISTINCT (11)&lt;Top Num&gt; &lt;select list&gt;(1)FROM left_table&lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4)WHERE &lt;where_condition&gt;(5)GROUP BY &gt; &lt;group_by_list&gt;(6)WITH &lt;CUBE | RollUP&gt;(7)HAVING &lt;having_condition&gt;(10)ORDER BY &lt;order_by_list&gt;
</code></pre>
<p>补充连接表时，ON效率比WHERE比WHERE高，因为ON根据条件筛选数据后再生成临时表，而where是在生成临时表后再根据字段过滤数据</p>
<h1 id="十一-子查询">十一、子查询</h1>
<p>在<code>SELECT</code>语句中，子查询总是从内向外处理</p>
<h2 id="在where中使用子查询">在<code>where</code>中使用子查询</h2>
<pre><code class="language-sql">SELECT
	cust_id 
FROM
	orders 
WHERE
	order_num IN ( # 注意
	SELECT # 子查询
		order_num 
	FROM
		orderitems 
WHERE
	prod_id = 'TNT2')
</code></pre>
<p>列必须匹配 在WHERE子句中使用子查询(如这里所示)，应 该保证SELECT语句具有与WHERE子句中相同数目的列。<strong>通常， 子查询将返回单个列并且与单个列匹配</strong>，但如果需要也可以 使用多个列。</p>
<h2 id="在from中使用子查询">在<code>from</code>中使用子查询</h2>
<pre><code class="language-sql">select name, id
from (
	select * from student where age&gt;10
) tmp;
</code></pre>
<h2 id="在select中的子查询作为计算字段的子查询">在<code>select</code>中的子查询，作为计算字段的子查询</h2>
<p>该查询是在逻辑上最难理解，也是实际使用中比较少使用的</p>
<p>例子</p>
<pre><code class="language-sql"># 作为计算字段的子查询
SELECT
	cust_name,
	cust_state,
	(
	SELECT
		count(*) 
	FROM
		orders 
	WHERE
		orders.cust_id = customers.cust_id 
	) AS orders 
FROM
	customers 
ORDER BY
	cust_name;
</code></pre>
<p>解释：因为子查询中的where依赖父查询的中的customers表，称为**相关子查询。**因此运行的时候，customer每取出一个新的cust_id，orders表就会按<code>where</code>约束得到一个新的汇总值。</p>
<p>注意：</p>
<p>使用作为计算字段的子查询是万不得已的选择，这样的查询方式在逻辑上不易理解，在排除错误时容易发生错误，而且计算的逻辑和SQL本身的逻辑违背</p>
<h1 id="十二-联结表-join">十二、联结表 JOIN</h1>
<p>主键和外键</p>
<p>主键是唯一标识一张表中唯一元素的</p>
<p>外键是引用其他表的某列，作为该表的某列的约束</p>
<h2 id="联结">联结</h2>
<p>注意联结本身不是物理存在而是数据库在查询时生成的临时表</p>
<p>创建联结的两种方式</p>
<ol>
<li>
<p>使用Where创建——sql92</p>
<pre><code class="language-sql">//SQL92
SELECT e.name, d,dname 
FROM emp e, dept d 
WHERE e.deptno = d.deptno and ...;
</code></pre>
</li>
<li>
<p>使用on创建——sql99</p>
<pre><code class="language-sql">SELECTe.name, d,dname 
FROM emp e join dept d 
ON e.deptno = d.deptno 
WHERE...;
</code></pre>
<p>多表联结时</p>
<pre><code class="language-sql">SELECT e.ename, d.name, s.grade 
from emp e 
join dept d # ！！！
on e.deptno = d.deptno 
join salgrade s # ！！！
on e.sal bewteen s.losal and s.hisal
</code></pre>
</li>
</ol>
<p>连接方式</p>
<ol>
<li>等值连接</li>
<li>区间连接</li>
</ol>
<p>内连接、外连接和全连接</p>
<p>解释：</p>
<p>内连接：只保留满足约束的联结</p>
<p>外连接：除了保留满足约束的部分，还会保留左（右）表中未在右（左）出现的行。</p>
<p>全连接：保留左右表中所有的未匹配的行，补空值。<strong>不常用</strong></p>
<p><strong>注意：区分内外连接的是 right和left关键词 不是inner和outer，可以缺省inner和outer</strong></p>
<p>例子</p>
<pre><code class="language-sql">SELECT e.name, d,dname 
from emp e 
left outer join dept d 
on e.deptno = d.deptno
</code></pre>
<p>两种方式的区别：</p>
<ol>
<li><code>on</code>比<code>where</code>高效</li>
<li><code>on</code>比<code>where</code>在结构上清晰</li>
</ol>
<p><strong>笛卡尔积</strong></p>
<p>不使用约束时的结果</p>
<h2 id="使用表别名">使用表别名</h2>
<h2 id="使用不同类型的联结">使用不同类型的联结</h2>
<h3 id="自联结">自联结</h3>
<p><code>from</code>后两个相同的表<code>join</code></p>
<pre><code class="language-sql">select e2.ename, e1.departmentId from 
employee e1 join employee e2 
on e1.departmentId = e2.departmentId
where e1.ename ='p1';
</code></pre>
<h3 id="自然联结">自然联结</h3>
<p>自然联结排除多次出现，使每个列只返回一次。系统不完成这项工作，由你自己完成它。</p>
<p>这一 般是通过对表使用通配符(SELECT *)，对所有其他表的列使用明确的子 集来完成的。</p>
<h1 id="十三-组合查询">十三、组合查询</h1>
<h2 id="union关键字"><code>UNION</code>关键字</h2>
<pre><code class="language-sql">(SELECT ...) # 查询1
UNION
(SELECT ...) # 查询2
</code></pre>
<p>规则</p>
<ol>
<li>由两个以上的<code>SELECT</code>子句组成</li>
<li>UNION两端的查询必须包含相同的列、表达式或函数（顺序不需要相同，MySQL会自动对齐）</li>
<li>数据类型必须兼容:类型不必完全相同。DBMS会自动隐式地转换格式</li>
</ol>
<h2 id="union-all关键字"><code>UNION ALL</code>关键字</h2>
<p><code>UNION</code>会<strong>自动去重</strong>，加上<code>ALL</code>参数后不会自动去重</p>
<p>注意：<code>UNION</code>和多子句<code>Where</code>在一般情况下是可以替换的，具体的效率需要具体问题具体分析，但是<code>UNION ALL</code>是不可以通过多子句<code>Where</code>完成的</p>
<h2 id="union排序"><code>UNION</code>排序</h2>
<p>放在所有子句的最后</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git教程]]></title>
        <id>https://dong1iu.github.io/post/git-jiao-cheng/</id>
        <link href="https://dong1iu.github.io/post/git-jiao-cheng/">
        </link>
        <updated>2021-06-15T08:58:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装git">安装GIT</h1>
<ol>
<li>安装homebrew</li>
<li>安装xcode</li>
</ol>
<h1 id="基础配置">基础配置</h1>
<p><code>git config —-global user.name &quot;Your name&quot;</code></p>
<p><code>git config -—global user.email &quot;yourEmail@example.com&quot;</code></p>
<p>查看设置是否成功</p>
<p><code>git config user.name</code></p>
<p>基本操作</p>
<p><code>add</code>、<code>commit</code></p>
<p>添加</p>
<p><code>git add &lt;file&gt;</code></p>
<p>提交</p>
<p><code>git commit -m &lt;message&gt;</code></p>
<h1 id="时光机">时光机</h1>
<p><code>git status</code></p>
<p>查看现在仓库的状态，会返回现在仓库哪些文件改动过和其他的信息</p>
<p><code>git diff</code></p>
<p>看得是**<code>工作区</code>**该文件与版本库中<code>当前分支</code>上该文件之间的差异</p>
<blockquote>
<p>严格地说，不一定，还可能是缓存区和仓库的区别，但在此处，我们简单的理解为上诉情况。</p>
</blockquote>
<ul>
<li>
<p>如何看懂<code>diff</code>的结果</p>
<pre><code class="language-bash">diff –-git a/f1 b/f1
index 8f86bb9..d74049c 100644
- a/f1
+++ b/f1
@@ -1,7 +1,7 @@  
code
code
code
-code
+code
code
code
code
</code></pre>
<ol>
<li><strong>第一行表示结果为git格式的diff</strong><code>diff --git a/f1 b/f1</code> 进行比较的是,a版本的f1(即变动前)和b版本的f1(即变动后)。</li>
<li><strong>第二行表示两个版本的git哈希值和最后的六位数字是对象的模式</strong><code>index 7a67204..8213f76 100644</code> index区域的7a67204对象,与工作目录区域的8213f76对象进行比较。<code>100</code>代表普通文件，<code>644</code>代表文件具有的权限（同linux文件权限）</li>
<li><strong>第三四行表示进行比较的两个文件</strong><code>a/f1+++ b/f1</code> &quot;-“表示变动前的版本，”+++&quot;表示变动后的版本。</li>
<li><strong>第五行表示代码变动的位置用两个@作为起首和结束</strong><code>@@ -1,7 +1,7 @@</code> &quot;-1,7″分成三个部分：减号表示第一个文件(即f1)，&quot;1″表示第1行，“7″表示连续7行。 合在一起，就表示下面是第一个文件从第1行开始的连续7行。 同样的，”+1,7″表示变动后，成为第二个文件从第1行开始的连续7行。</li>
<li><strong>第三部分是变动的具体内容</strong><code>code</code> 变动的行，上下文各显示3行。将两个文件上下文合并显示在一起。 每一行最前面的标志位：“-”代表第一个文件删除的行用红色表示，“+”表示第二个文件新增的行用绿色表示，无标志表示该行无变动。</li>
</ol>
</li>
</ul>
<p>提交修改的步骤</p>
<p>提交修改的步骤和添加文件的步骤是一样的</p>
<ol>
<li><code>git add modified_file_name</code></li>
<li><code>git commit -m &quot;comment&quot;</code></li>
</ol>
<h2 id="版本回退">版本回退</h2>
<h3 id="查看过去的版本">查看过去的版本</h3>
<p><code>git log -n 3 --pretty=oneline</code></p>
<p><code>-n 3</code> → 查看过去的三个版本</p>
<p><code>--pretty=oneline</code> → 美化结果为一行</p>
<p>如果希望以图的形式展示分支结构</p>
<p><code>--graph</code></p>
<ul>
<li>
<p>结果</p>
<pre><code class="language-bash"># 美化的
# commit_id ... comment
9cda832cca9f6c1cf77eae5afa42e3b5d7af3580 (HEAD -&gt; master) add version 3
272ad41ad60b17bd6e00506da5166953dcfc4ede add version 2
e245982e0e475d8a2c84209adaff560b7e42eadb add version 1

# 不美化的
commit 272ad41ad60b17bd6e00506da5166953dcfc4ede
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:51:24 2021 +0800

    add version 2

commit e245982e0e475d8a2c84209adaff560b7e42eadb
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:50:51 2021 +0800

    add version 1
dong1iu@IMAC-dong1iu gittest % git log -n 1
commit 9cda832cca9f6c1cf77eae5afa42e3b5d7af3580 (HEAD -&gt; master)
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:52:11 2021 +0800
</code></pre>
</li>
</ul>
<h3 id="回到过去的版本">回到过去的版本</h3>
<p><code>git reset --hard HEAD^</code></p>
<p><code>HEAD</code>指向的版本就是当前版本</p>
<h2 id="工作区-暂存区和库">工作区、暂存区和库</h2>
<p>⭐网络上很多博客关于这一部分的讲述都是不清晰的，我整理了廖雪峰git教程下网友的评论，以下是我认为正确的内容</p>
<h3 id="逻辑结构">逻辑结构</h3>
<ol>
<li>工作区（woking directory）</li>
<li>版本库
<ol>
<li>暂存区（stage or index）</li>
<li>库（head）</li>
</ol>
</li>
</ol>
<h3 id="添加过程">添加过程</h3>
<p><strong>注意：</strong><code>git</code>的任务是完成版本管理，所以在底层其实就是移动数据。</p>
<p>初始化完成后，三个区域都是空的</p>
<p>在编辑一个新的<code>readme.md</code>文件(v1)后，工作区会出现一个新的<code>untracked</code>文件，此时你<code>add</code>到缓存区，然后修改<code>readme.md</code>文件(v2)。到现在为止，你的工作区和缓存区很明显是不同的，指令<code>git diff</code>就是比较你的工作区和缓存区的不同。</p>
<p>现在，你在不add的情况下，直接将没有重新<code>add</code>的缓存区<code>commit</code>到你的库(<code>head</code>)，自然你的库中应该是保存的你第一次编辑的<code>readme.md</code>文件(v1)。注意，此时你的缓存区不是&quot;清空&quot;的状态，而是和<code>commit</code>前保持一样的状态，区别是你的缓存区和head的状态一致，所以<code>git status</code>提示你的<code>nothing to commit, working tree clean</code></p>
<p>那么如何比较你的工作区和库呢？答案是<code>git diff HEAD -- filename</code></p>
<h3 id="总结">总结</h3>
<p>比较工作区和缓存区 → <code>git diff</code></p>
<p>比较工作区和库 → <code>git diff HEAD -- filename</code></p>
<p>比较缓存区和库 → <code>git diff -cached</code></p>
<p>比较不同库版本 →<code>git diff 243550a 24bc01b</code> →<code>git diff commit_id1 commit_id2</code></p>
<p><code>git add</code>的<strong>逆</strong>操作 → <code>git checkout -- filename</code></p>
<p>注意：</p>
<ol>
<li><code>git add</code>本质是把暂存区的数据同步为工作区的数据，而checkout是将工作区的数据同步为stage中的数据。</li>
<li><code>--</code>不能少，<em><strong>有空格</strong></em>，不然命令会出错，变成了“切换到另一个分支”的命令，</li>
<li><code>git checkout --filename</code>在新版<code>git</code>中现在被<code>git restore</code>替代</li>
<li>原来的<code>git reset HEAD</code> 可以使用 <code>git restore --staged</code> 代替</li>
<li>原来的<code>git checkout branchName</code> 可以用 <code>git switch branchName</code> 代替。</li>
</ol>
<p>撤销<code>add</code> → <code>git restore --staged &lt;file&gt;...</code></p>
<p><code>unstage</code>操作，取消add操作</p>
<h2 id="删除文件">删除文件</h2>
<p>在工作区删除文件</p>
<p><code>rm filename</code></p>
<p>从库中删除文件</p>
<p><code>git rm filename</code></p>
<p><code>git commit -m &quot;delete filename&quot;</code></p>
<p>恢复被删除的文件</p>
<p><code>git restore filename</code>或<code>git checkout -- filename</code></p>
<p>原理上来说，缓存区的文件和版本库的文件是一致的，所以你可以从缓存区恢复你的文件。</p>
<h1 id="远程仓库">远程仓库</h1>
<h2 id="如何连接到你的远程仓库">如何连接到你的远程仓库</h2>
<ol>
<li>
<p>注册你的github账号</p>
</li>
<li>
<p>创建SSH key</p>
<p><code>ssh-keygen -t rsa -C &quot;youremial@example.com&quot;</code></p>
<p>一般在<code>用户主目录/.ssh</code>下，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，前者是私钥，后者是公钥。</p>
<p><em><strong>注意：千万不要丢失自己的私钥！！！</strong></em></p>
</li>
<li>
<p>添加公钥到github账号</p>
<p>Account settings → SSH and CPG keys → new ssh key</p>
</li>
</ol>
<h2 id="添加远程库">添加远程库</h2>
<h3 id="创建新的仓库">创建新的仓库</h3>
<p>在github仓库主页上 new repository</p>
<h3 id="关联本地仓库">关联本地仓库</h3>
<p><code>git remote add origin git@github.com:dong1iu/learngit.git</code></p>
<p>远程库的名字就是<code>origin</code></p>
<h3 id="推送">推送</h3>
<p><code>git push -u origin master</code></p>
<p>第一次时使用<code>-u</code>代表关联，把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。以后可以简单是使用<code>git push origin master</code></p>
<p>notes: <code>-f</code>参数可以强制推送</p>
<h3 id="删除远程库连接">删除远程库连接</h3>
<p><code>git remote -v</code> → 查看远程库信息</p>
<p><code>git remote rm origin</code> → 删除本地仓库<strong>连接远程仓库</strong>（比如github上的learngit仓库）<strong>的连接。</strong></p>
<p>注意：</p>
<p><code>git push origin -d dev</code> → 删除远程数据库上的分支</p>
<h3 id="如何理解origin">如何理解Origin</h3>
<p>origin其实只是一个别名，按照我的理解，他是代表你本地仓库到远程仓库这个连接的名字。因为你push的时候需要知道你push到哪儿去了，所以你要指名这个连接，而完整的连接名太长，也不方便记忆和理解，所以使用origin来作为别称。另外，你从github上clone代码的时候，github会自动的把这个连接称为origin。</p>
<h2 id="从远程库克隆">从远程库克隆</h2>
<p><code>git clone git@github.com:dong1iu/gitskills.git</code></p>
<h1 id="分支管理">分支管理</h1>
<p>首先我们要明白git分支的工作原理</p>
<p>请参看廖雪峰分支管理</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点</p>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623747851195.png" alt="" loading="lazy"></figure>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623747861961.png" alt="" loading="lazy"></figure>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<figure data-type="image" tabindex="3"><img src="https://dong1iu.github.io/post-images/1623747871215.png" alt="" loading="lazy"></figure>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<figure data-type="image" tabindex="4"><img src="https://dong1iu.github.io/post-images/1623747879062.png" alt="" loading="lazy"></figure>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<figure data-type="image" tabindex="5"><img src="https://dong1iu.github.io/post-images/1623747887057.png" alt="" loading="lazy"></figure>
<h2 id="创建和合并分支">创建和合并分支</h2>
<p>创建分支</p>
<p><code>git branch branchname</code></p>
<p>切换分支</p>
<p><code>git switch branchname</code></p>
<p>注意：当你切换分支时，HEAD的位置会变化，也就是说，你在某个分支上做的变化，在另一个分支上是看不到的</p>
<p>查看分支</p>
<p><code>git branch</code></p>
<pre><code class="language-sql">* dev
  master
</code></pre>
<p>星号代表当前HEAD所在分支</p>
<p>创建并切换分支</p>
<p><code>git switch -c branchname</code></p>
<p>合并某分支到当前分支</p>
<p><code>git merge branchname</code></p>
<p>删除分支</p>
<p><code>git branch -d branchname</code></p>
<p>删除远程上的分支</p>
<p><code>git push origin -d dev</code></p>
<h2 id="分支冲突">分支冲突</h2>
<p>在分支<code>master</code>和分支<code>dev</code>中分别修改<code>readme.md</code>的最后一行然后add并commit，merge的时候会发生冲突</p>
<p>此时处理的方式</p>
<ol>
<li>
<p>放弃merge</p>
<p><code>git merge --abort</code></p>
</li>
<li>
<p>修改冲突的文件并提交</p>
<ol>
<li>
<p><code>vim conflict_file</code></p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev
</code></pre>
</li>
<li>
<p><code>git add conflict_file</code></p>
</li>
<li>
<p><code>git commit -m &quot;merge conflict fixed&quot;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="分支策略">分支策略</h2>
<p>默认的情况下，git的merge采用fast forward策略，这种策略比较快，但是在改模式下，删除分支后会失去信息，使用<code>--no-ff</code>参数禁用fast forward策略</p>
<figure data-type="image" tabindex="6"><img src="https://dong1iu.github.io/post-images/1623747897906.png" alt="" loading="lazy"></figure>
<h1 id="标签管理">标签管理</h1>
<h2 id="创建标签">创建标签</h2>
<p>查看便签</p>
<p><code>git tag</code></p>
<p>添加便签</p>
<p><code>git tag &lt;name&gt;</code></p>
<p>给过去的<code>commit_id</code>添加标签</p>
<p><code>git tag &lt;name&gt; &lt;commit_id&gt;</code></p>
<p>查看已有的便签</p>
<p><code>git tag</code></p>
<p>查看标签信息</p>
<p><code>git show &lt;tag&gt;</code></p>
<p>其他说明</p>
<ol>
<li>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</li>
<li>标签不是按时间顺序列出，而是按字母排序的</li>
</ol>
<h2 id="操作标签">操作标签</h2>
<p>删除</p>
<p><code>git tag -d v0.1</code></p>
<p>推送某个标签</p>
<p><code>git push origin v1.0</code></p>
<h1 id="github">Github</h1>
<h2 id="查看当前的远程库">查看当前的远程库</h2>
<p>git remote -v</p>
<h2 id="提取远程仓库">提取远程仓库</h2>
<h3 id="从远程仓库下载新分支与数据">从远程仓库下载新分支与数据</h3>
<p><code>git fetch</code></p>
<h3 id="从远端仓库提取数据并尝试合并到当前分支">从远端仓库提取数据并尝试合并到当前分支</h3>
<p><code>git merge</code></p>
<h2 id="推送到远程仓库">推送到远程仓库</h2>
<p><code>git push -u origin master</code></p>
<h2 id="删除远程仓库中的分支">删除远程仓库中的分支</h2>
<p><code>git push origin -d dev</code> → 删除远程数据库上的分支</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[留存分析——Cohort分析]]></title>
        <id>https://dong1iu.github.io/post/liu-cun-fen-xi-cohort-fen-xi/</id>
        <link href="https://dong1iu.github.io/post/liu-cun-fen-xi-cohort-fen-xi/">
        </link>
        <updated>2021-06-09T08:59:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是cohort分析">什么是Cohort分析</h1>
<p>Cohort Analysis 可以翻译成 群体分析 或 分组分析，其实是一种通过细分来研究数据的方法。如下表就是一个从每日新增维度细分的 Cohort Analysis 表格。<br>
<img src="https://dong1iu.github.io/post-images/1623229217530.png" alt="" loading="lazy"></p>
<h1 id="如何实现cohort分析">如何实现Cohort分析</h1>
<p>分组先分维度，再分粒度<br>
维度：你观察的用户分类，举例而言，注册账号的平台、设备、注册时间、性别等<br>
粒度：直白的说就是观察的间隔，比如以月、周、天、12小时等</p>
<h1 id="python实现cohort分析">python实现cohort分析</h1>
<h2 id="读取数据">读取数据</h2>
<ol>
<li>如果你的数据在数据库中，可以直接使用SQL查询</li>
<li>如果你的数据是冷数据，存放在文件中，可以用python直接读取，根据格式的不同使用不同的包，比如<code>pd.read_csv()</code></li>
</ol>
<h2 id="预处理数据">预处理数据</h2>
<p>根据既定的规则，处理数据。使用Pandas自带的函数等，例如map, apply, filter, 布尔索引等<br>
根据你的粒度，处理不同的生成新的时间列，可以命名为回访事件时间</p>
<h2 id="分组">分组</h2>
<p>使用<code>df.groupby(by=[...])</code>函数分组，和数据库中的group by异曲同工，不同的是，在Python中你可以轻易的进行数据透视，但是在SQL中相对比较复杂。当公司有稳健的数据库系统时，推荐使用SQL和Python结合的方式，即GROUPBY的工作由性能强大的数据库完成，数据透视由Python完成。</p>
<h2 id="数据透视">数据透视</h2>
<p>经过分组，我们等到的形如以下的结果</p>
<table>
<thead>
<tr>
<th>注册</th>
<th>注册时间</th>
<th>活跃</th>
<th>活跃时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>2020-01-01</td>
<td>A</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>B</td>
<td>2020-01-01</td>
<td>B</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>C</td>
<td>2020-01-01</td>
<td>C</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>A</td>
<td>2020-01-01</td>
<td>A</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>C</td>
<td>2020-01-01</td>
<td>C</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>B</td>
<td>2020-01-01</td>
<td>B</td>
<td>2020-01-03</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-03</td>
</tr>
</tbody>
</table>
<p>我们要完成的即一个数据透视工作，使用<code>pd.pivot_table()</code>完成</p>
<h1 id="代码参考">代码参考</h1>
<p>这里只给出主函数，因为函数的功能非常复杂，所以我们不细讲，只作为一个参考提供给大家</p>
<pre><code class="language-python">def gcohort(df, group_names, ncolumn='n', orient='倒三角', pre_filter=None, 
    init_event=None, init_agg={}, init_name=None,
    recall_event=None, recall_agg={}, recall_apply={},
    final_func=None, final_args=None):
    &quot;&quot;&quot;
    分群/对偶分析
    示例
        1.留存分析
            group_names = ['af_channel', 'country_code']
            trans_map = {'callback_time':'日期', 'af_channel':'渠道', 'country_code':'国家码'}
            
            gcohort(df, group_names, ncolumns='n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'},\
                init_name='激活', \
                recall_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                final_func=lambda x: x.rename(columns=trans_map))
        2. LTV计算
            # event_value_sum函数负责把event_value中的花费提取并加总，两个后处理函数分别负责补洞和累加和除
            ltv = gcohort(ddwwy, [], 'n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                init_name='激活', \
                recall_event='af_purchase', \
                recall_apply={'agg_func': event_value_sum, &quot;agg_args&quot;: {}}, \
                final_func=[
                    {&quot;func&quot;: fill_gcohort, &quot;kargs&quot;: {&quot;group_names&quot;: [], &quot;interval&quot;: '12h', &quot;orient&quot;: &quot;倒三角&quot;, &quot;time_col&quot;: &quot;时间&quot;}},  # 补洞
                    {&quot;func&quot;:ltv_cumsum_new, &quot;kargs&quot;: {&quot;time_col&quot;: &quot;时间&quot;, &quot;div_col&quot;:&quot;激活&quot;}},  # 累计LTV
                    ])
        3. 广告点击
            ltv = gcohort(ddwwy, [], 'n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                init_name='激活', \
                recall_event='af_ad_click', \
                recall_agg={'agg_column':'device_id', 'agg_method':'count'}, \
                final_func=[
                    {&quot;func&quot;: fill_gcohort, &quot;kargs&quot;: {&quot;group_names&quot;: [], &quot;interval&quot;: '12h', &quot;orient&quot;: &quot;倒三角&quot;, &quot;time_col&quot;: &quot;时间&quot;}},  # 补洞
                    ])
        
    ----------
    Parameters
    ----------
    df : DataFrame.
        输入的源日志文件
    group_names : list.
        不包含时间和ncolumn的分组项
    ncolumn : str.
        时间差 取决于你分析表格的时间间隔列名字
    orient : str
        可选 ['正三角', '倒三角']
        orient决定回访事件分析是 是分群分析还是对偶分析
        
    pre_filter : func or list
        自定义的预处理函数 -&gt; 建议在此处对激活日期筛选
    init_evnet : str, list, func, DataFrame.
        可接受 [初始事件名, 初始事件字符串列表, 函数, 计算好的初始事件表]
    init_agg : dict
        init_event的聚合参数，需构造以下字典
        {
            &quot;agg_column&quot;: str. 聚合的列名,
            &quot;agg_method&quot;: str or func | 内置的字符串或自定义方法, 
        }
        注意：此参数只在init不是DataFrame类型时有效，即未输入计算好的初始事件表
    init_name : str. default is None
        聚合后初始事件列名
        
    recall_event : str, list or func. default is None
        召回事件
        当其为字符或字符串组成的列表时，从df中过滤事件 
    recall_agg : dict. default is {}
        召回事件的聚合参数 需构造以下字典
        列表的
            {
                &quot;agg_column&quot;: str. 聚合列名,
                &quot;agg_method&quot;: str or func. 聚合方法 支持agg内置的字符选项如 count sum nunique max等 也支持自定义func, 
                &quot;pivot_agg_method&quot;: str or func. 数据透视表的聚合方式 支持aggfunc内置字符如 sum first 也支持自定义func,
            }
        
    recall_apply : dict. default is {}
        召回事件的另一种聚合参数 需构造以下字典
            {
                &quot;agg_func&quot;: str. 聚合方法,
                &quot;agg_args&quot;: dict. 聚合方法的参数字典 (args), 
                &quot;pivot_agg_method&quot;: str or func. 数据透视表的聚合方式 支持aggfunc内置字符如 sum first 也支持自定义func,
            }

        recall = recall_df.groupby(k,...).agg({recall_agg[0], recall_agg[1]})
    final_func : func or list
        函数 字典 函数组成的列表 字典组成的列表 函数和字典混合组成的列表
        后处理函数或后处理函数列表
        例如
            1. 函数
                func = lambda x:x
            2. 字典
                {
                    &quot;func&quot;: add
                    &quot;kargs&quot;: {&quot;arg1&quot;: &quot;value1&quot;, &quot;arg2&quot;: &quot;value2&quot;}
                }
            3. 函数组成的列表
                [lambda x:x, lambda x:x, lambda x:x]
            ...
    &quot;&quot;&quot;
    # 资格审查
    if 'init_time' not in df.columns and 'callback_time' not in df.columns:
        print('源文件必须包含init_time和callback_time')
    
    # 源日志预处理 =========
    if callable(pre_filter):
        df = pre_filter(df)
    elif isinstance(pre_filter, list):
        for pf in pre_filter:
            df = pf(df)
    
    # 时间列判断
    # 初始事件时间 init_time, callback_time 此   这两个时间的粒度可以是月 周 天 小时等
    if orient == '正三角':
        time_col = 'callback_time'
        print('==对偶分析==')
    elif orient == '倒三角':
        time_col = 'init_time'
        print('==gcohort分析==')
    else:
        print(f'不可选的orient{orient}')
        return 
    
    # 初始事件 =============
    print('==处理初始事件==')
    # 初始事件准备
    init = None
    if init_event is None:
        init_df = df  # event为空时 默认具体
    elif isinstance(init_event, DataFrame):
        init = init_event  # 可接受计算好的初始事件表, 需要注意是输入的init_event必须和recall矩阵拥有相同的粒度和时间格式 否则表连接会错误
    elif isinstance(init_event, str):
        init_df = df[df.event_name==init_event]
    elif isinstance(init_event, list):
        init_df = df[df.event_name.isin(init_event)]
    elif callable(init_event):
        init_df = init_event(df)
    else:
        print(f'不支持的初始事件（init_event）参数：{init_event}')
        return
    # NOTE：对于激活事件 不建议在gcohort函数中聚合 
    #       因为源日志中的激活事件可能不齐全
    
    init_k = group_names + ['init_time']
    # 初始事件聚合
    if init is None:
        init = init_df.groupby(init_k, observed=True)\
            .agg({init_agg['agg_column']: init_agg['agg_method']})\
            .reset_index()\
            .rename(columns={init_agg['agg_column']:init_name})
    init = init.rename(columns={'init_time':'时间'})
    
    
    # 召回事件 =============
    print('==处理召回事件==')
    
    if recall_event is None:
        recall_df = df
    elif isinstance(recall_event, str):
        recall_df = df[df.event_name==recall_event]
    elif isinstance(recall_event, list):
        recall_df = df[df.event_name.isin(recall_event)]
    elif callable(recall_event):
        recall_df = recall_event(df)
    
    # 召回事件聚合
    if (recall_agg and recall_apply) or (not recall_agg and not recall_apply):
        print('recall_agg和recall_apply只可选其一')
        return
    
    pindex = group_names + [time_col]
    recall_k = pindex + [ncolumn]
    
    if recall_agg:
        aggfunc = recall_agg['pivot_agg_method'] if recall_agg.get('pivot_agg_method') else 'sum'
        recall = recall_df.groupby(recall_k, observed=True)\
            .agg({recall_agg['agg_column']:recall_agg['agg_method']})\
            .pivot_table(index=pindex, columns=ncolumn, values=recall_agg['agg_column'], aggfunc=aggfunc)\
            .reset_index()
    else:
        aggfunc = recall_apply['pivot_agg_method'] if recall_apply.get('pivot_agg_method') else 'sum'
        recall = recall_df.groupby(recall_k, observed=True) \
            .apply(recall_apply['agg_func'], recall_apply['agg_args']) \
            .reset_index() \
            .pivot_table(index=pindex, columns=ncolumn, values=0, aggfunc=aggfunc) \
            .reset_index()
            # values=0因为apply聚合后默认列名为0
    recall = recall.rename(columns={time_col: '时间'})
    
    # 连接初始表和召回表 =================================
    ans = init.merge(recall, on=group_names+['时间'], how='outer')
                
    # 后处理 ===============
    if callable(final_func):
        ans = final_func(ans)
    elif isinstance(final_func, dict):
        func = final_func.get(&quot;func&quot;)
        kargs = final_func.get(&quot;kargs&quot;)
        ans = func(ans, **kargs)
    elif isinstance(final_func, list):
        for afunc in final_func:
            if callable(afunc):
                ans = afunc(ans)
            if isinstance(afunc, dict):
                func = afunc.get(&quot;func&quot;)
                kargs = afunc.get(&quot;kargs&quot;)
                ans = func(ans, **kargs)
    # 补洞交由后处理函数函数 或 对返回的ans处理
    return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Pandas DataFrame 中使用比较列表的问题]]></title>
        <id>https://dong1iu.github.io/post/zai-pandas-dataframe-zhong-shi-yong-bi-jiao-lie-biao-de-wen-ti/</id>
        <link href="https://dong1iu.github.io/post/zai-pandas-dataframe-zhong-shi-yong-bi-jiao-lie-biao-de-wen-ti/">
        </link>
        <updated>2021-06-01T08:21:50.000Z</updated>
        <content type="html"><![CDATA[<p>如果你经常尝试在DataFrame中存放列表并对列表进行过取等，你会发现结果这和你预想的不同</p>
<pre><code class="language-python">df = pandas.DataFrame([[1,2,3,[4,5]],[6,7,8,[9,10]]], columns=['a','b','c','d'])
&gt;&gt;&gt; df
   a  b  c        d
0  1  2  3   [4, 5]
1  6  7  8  [9, 10]
</code></pre>
<p>当你用d构建过滤器的时候</p>
<pre><code class="language-python">&gt;&gt;&gt; df['d'] == [4,5]
0    False
1    False
Name: d, dtype: bool
</code></pre>
<p><strong>造成这种现象的原因是，DataFrame中存储的列表不可哈希（散列）</strong><br>
如果你想正确的构建过滤器，你可以用一下方式</p>
<pre><code class="language-python">df.loc[:, 'd'].map(lambda x:x==[4,5])
</code></pre>
<p>这种方式调用匿名函数逐个比较，而不是使用哈希表比较，自然不会造成之前的错误</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu防火墙管理]]></title>
        <id>https://dong1iu.github.io/post/ubuntu-fang-huo-qiang-guan-li/</id>
        <link href="https://dong1iu.github.io/post/ubuntu-fang-huo-qiang-guan-li/">
        </link>
        <updated>2021-05-28T02:25:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>系统版本: ubuntu18.04</p>
</blockquote>
<h2 id="查看防火墙当前状态">查看防火墙当前状态</h2>
<p><code>sudo ufw status</code></p>
<h2 id="开启防火墙">开启防火墙</h2>
<blockquote>
<p>开启时请以前打开22端口的权限，否则无法ssh到机器</p>
</blockquote>
<p><code>sudo ufw enable</code></p>
<h2 id="ufw启用关闭重载">ufw启用/关闭/重载</h2>
<p><code>ufw enable/disable/reload</code></p>
<h2 id="允许外部访问80端口">允许外部访问80端口</h2>
<p><code>sudo ufw allow 80</code></p>
<h2 id="禁止外部访问80端口">禁止外部访问80端口</h2>
<p><code>sudo ufw delete allow 80</code></p>
<h2 id="允许此ip访问所有的本机端口">允许此IP访问所有的本机端口</h2>
<p><code>sudo ufw allow from 192.168.1.1</code></p>
<h2 id="禁止外部访问smtp服务">禁止外部访问smtp服务</h2>
<p><code>sudo ufw deny smtp</code></p>
<h2 id="安装ufw">安装ufw</h2>
<p><code>sudo apt-get install ufw</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac OS 时间机器全力备份]]></title>
        <id>https://dong1iu.github.io/post/mac-os-shi-jian-ji-qi-quan-li-bei-fen/</id>
        <link href="https://dong1iu.github.io/post/mac-os-shi-jian-ji-qi-quan-li-bei-fen/">
        </link>
        <updated>2021-05-26T05:03:46.000Z</updated>
        <content type="html"><![CDATA[<p>全力备份</p>
<p><code>sudo sysctl debug.lowpri_throttle_enabled=0</code></p>
<p>静默备份</p>
<p><code>sudo sysctl debug.lowpri_throttle_enabled=1</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python数据规整化：清理、转换、合并、重塑]]></title>
        <id>https://dong1iu.github.io/post/python-shu-ju-gui-zheng-hua-qing-li-zhuan-huan-he-bing-chong-su/</id>
        <link href="https://dong1iu.github.io/post/python-shu-ju-gui-zheng-hua-qing-li-zhuan-huan-he-bing-chong-su/">
        </link>
        <updated>2021-05-19T08:30:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="合并数据集">合并数据集</h1>
<h2 id="数据库风格的合并">数据库风格的合并</h2>
<pre><code class="language-python">pd.merge(df1, df2, on='key')
# 如果列的名字不同
pd.merge(df1, df2, left_on='key1', right_on='key2')
# how= inner left right outter
pd.merge(df1, df2, on='key', how='innner')

</code></pre>
<p>多对多连接时产生的时行的笛卡尔积</p>
<p>要根据多个键合并时，传入一个由列名组成的列表即可</p>
<pre><code class="language-python">pd.merge(df1, df2, on=['key1', 'key2'], how='innner')
</code></pre>
<p>注意在进行列连接时，DataFrame对象中的索引会被丢弃</p>
<p>对重复列名的处理</p>
<pre><code class="language-python">pd.merge(left, right, on='key', suffixes=('_left', '_right')
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623227523966.png" alt="" loading="lazy"></figure>
<p>完整参数<br>
<img src="https://dong1iu.github.io/post-images/1623227533897.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623227537948.png" alt="" loading="lazy"></figure>
<h2 id="索引上的合并">索引上的合并</h2>
<pre><code>如果连接键位于起索引中，可传入left_index=True或right_index=True(或都传)以说明索引应该被用作连接键

```python
pd.merge(left, right, left_on='key', right_index=True)
```

对于层次化索引， 比较复杂
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dong1iu.github.io/post-images/1623227546081.png" alt="" loading="lazy"></figure>
<pre><code>必须以列表的形式指明用作合并键的多个列

```python
pd.merge(left, right, left_on=['key1, key2'], right_index=True)
```

join实例方法 df.join

默认左连接

```python
left.join(right, on='key', how='inner')
```
</code></pre>
<h1 id="轴向连接">轴向连接</h1>
<h2 id="concat">concat</h2>
<p>可称为连接（concatenation）、绑定（binding）或堆叠（stacking）</p>
<p>concatenation 用于合并原始Numpy数组<br>
<img src="https://dong1iu.github.io/post-images/1623227551979.png" alt="" loading="lazy"></p>
<pre><code class="language-python">np.concatenate([arr, arr], axis=1)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://dong1iu.github.io/post-images/1623227556829.png" alt="" loading="lazy"></figure>
<p>对于pandas对象，带有标签的轴使你能够进一步推广数组的连接，所以concatenate的可用性就不高了</p>
<p>使用CONCAT函数</p>
<pre><code class="language-python"># 带标签
pd.concat([s1, s2, s3])
# 默认axis=0
pd.concat([df1, df2, df3], axis=0)
</code></pre>
<p>参数join</p>
<pre><code class="language-python"># 舍弃 两个Series中不共有的位置
pd.concat([s1, s2], axis=0, join='inner')
</code></pre>
<p>参数joinaxes 指定在其他轴上使用的索引</p>
<pre><code class="language-python">pd.concat([s1, s2], axis=0, join_axes=[['a', 'b'])
</code></pre>
<p>参数keyx 用于区分连接的结果</p>
<pre><code class="language-python">In [70]: result = pd.concat([s1,s2,s3], keys=['one', 'two','three'])
Out[70]: result
one    a  0
        b  1
two    a  0
                b  1
three  f  5
        g  6
</code></pre>
<p>如果沿着axis=1对Series进行合并，这keys会成为DataFrame的列头</p>
<p>如果keys传入的不是列表而是字典，那么字典的键会被当做keys选项的值</p>
<p>处理和分析工作无关的index</p>
<pre><code class="language-python">pd.concat([df1, df2], ingore_indexx=True)
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://dong1iu.github.io/post-images/1623227564113.png" alt="" loading="lazy"></figure>
<h2 id="合并重叠数据">合并重叠数据</h2>
<p>使用np.where重叠</p>
<pre><code class="language-python">np.where(pd.isnull(a), b, a)
</code></pre>
<p>使用combine_first</p>
<pre><code class="language-python">b[:2].combine_first(a[:])
</code></pre>
<p>##重塑和轴向旋转</p>
<p>重塑层次化索引</p>
<p>stack和unstack方法分别将数据的列旋转为行、将数据的行旋转为列</p>
<p>STACK方法<br>
<img src="https://dong1iu.github.io/post-images/1623227569712.png" alt="" loading="lazy"></p>
<pre><code class="language-python">data.stack()
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://dong1iu.github.io/post-images/1623227574396.png" alt="" loading="lazy"></figure>
<p>UNSTACK方法<br>
<img src="https://dong1iu.github.io/post-images/1623227579478.png" alt="" loading="lazy"></p>
<p>默认情况unstack操作的是最内层（同stack）。可以传入级别的编号和名称</p>
<pre><code class="language-python">result.unstack(0)
result.unstack('state')
</code></pre>
<p>如果不是所有级别值都能在个分组中找到的话，这unstack操作会引入NAN，而stack()方法默认会过滤缺失值，所以两方法是可逆的</p>
<h2 id="将长表转换为宽表">将长表转换为宽表</h2>
<figure data-type="image" tabindex="7"><img src="https://dong1iu.github.io/post-images/1623227586212.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.pivot('date', 'item', 'value')
</code></pre>
<p>前两个参数分别作为行列索引的列名，最后一个是填充DF数据列名的。<br>
<img src="https://dong1iu.github.io/post-images/1623227592594.png" alt="" loading="lazy"></p>
<p>如果有两个需要参与重塑的数据列</p>
<pre><code class="language-python">pivoted = df.pivo('date', 'item')
# 忽略最后一个参数得到的DF就会带有层次化的列
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://dong1iu.github.io/post-images/1623227597553.png" alt="" loading="lazy"></figure>
<p>注意pivot其实只是一个快捷方式：实质上用set_index创建层次化soyb，再用unstack重塑。</p>
<h1 id="移除重复数据">移除重复数据</h1>
<p>duplicated 方法 返回一个布尔型Series</p>
<pre><code class="language-python">data.duplicated()
</code></pre>
<p>drop_duplicates() 默认只保留第一行</p>
<pre><code class="language-python">df.drop_duplicates(subset=['a', 'b'], keep='first', inplace=False, ingore_index=False)
# - first : Drop duplicates except for the first occurrence. - last : Drop duplicates except for the last occurrence. - False : Drop all duplicates.
# If True, the resulting axis will be labeled 0, 1, …, n - 1.
</code></pre>
<h1 id="使用函数或映射进行数据装换">使用函数或映射进行数据装换</h1>
<p>Series的map方法可以接受一个函数或含有映射关系的字典型对象</p>
<pre><code class="language-python"># meat_to_animal是一个字典
data['animal'] = data['food'].map(str.lower).map(meat_to_animal)
</code></pre>
<p>也可以传入完整的数据</p>
<pre><code class="language-python">data['animal'] = data['food'].map(lambda x: meat_to_animal[x.lower()])
</code></pre>
<h1 id="替换值">替换值</h1>
<p>replace 函数</p>
<pre><code class="language-python">data.place([-999, -1000], np.nan)
</code></pre>
<p>也可以传入字典</p>
<pre><code class="language-python">data.replace({-999:np.nan, -1000:0})
</code></pre>
<h1 id="重命名轴索引">重命名轴索引</h1>
<p>和Series一样，轴标签也有一个map方法</p>
<pre><code class="language-python">data.index.map(str.upper)
</code></pre>
<p>rename 方法</p>
<pre><code class="language-python">df.rename(index=str.title, columns=str.upper)
</code></pre>
<p>也可以传入字典修改</p>
<h1 id="离散化和面元bin划分">离散化和面元（bin）划分</h1>
<p>cut方法</p>
<pre><code class="language-python">bins = [18, 25, 35, 60, 100]
cats = pd.cut(ages, bins)
</code></pre>
<p>pandas会返回特殊的Categorical对象，他实际上是表示不同分类名称的levels数组以及一个为年龄数据进行标号的labels属性</p>
<pre><code class="language-python">In [157]: cats.labels 
Out[157]: array([o, o, o, 1, o, o, 2, 1, 3, 2, 2, 1]) 
In (158]: cats.levels 
Out[158]: Index([(18, 25], (25, 35], (35, 60], (60, 100]], dtype=object) 
In [159]: pd.value_counts(cats) 
Out[159]:
(18, 25]    5
(35, 60]    3
(25, 35]    3 
(60, 100]   1
</code></pre>
<p>right参数 修改区间的取向</p>
<pre><code class="language-python"># right不取右边
pd.cut(ages, bins, right=False)
</code></pre>
<p>label参数 设置自己分箱名称</p>
<pre><code class="language-python">pd.cut(ages, labels=['Youth', 'YoungAdult', ...])
</code></pre>
<p>如果传入的分箱的数量而不是确切的临界值，则他会根据数据的最小值和最大值计算等距分箱</p>
<pre><code class="language-python">pd.cut(data, 4, precision=2)
</code></pre>
<p>QCUT</p>
<p>根据样本的分位数进行分箱</p>
<pre><code class="language-python">pd.qcut(data, 4)
# 也可以自己设置
pd.qcut(data, [o, 0.1, o.s, 0.9, 1.))
</code></pre>
<h1 id="检测和过滤异常值">检测和过滤异常值</h1>
<p>找出绝对值大小超过3的值</p>
<pre><code class="language-python">col[np.abs(col) &gt; 3]
</code></pre>
<p>选出全部含有“超过3或-3的值”的行，使用any方法</p>
<pre><code class="language-python">data[(np.abs(data) &gt; 3).any(1)]
</code></pre>
<p>将df中的值重新限制到-3到3之间</p>
<pre><code class="language-python">data[np.abs(data) &gt; 3] = np.sign(data) * 3
</code></pre>
<h1 id="排列和随机采样">排列和随机采样</h1>
<p>利用numpy.random.permutation函数可以轻松实现对Series或DataFrame的列的排列工作（permuting）。通过需要排列的轴长度调用permutation，可以产生一个表示新顺序的整数数组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAC终端代理]]></title>
        <id>https://dong1iu.github.io/post/mac-zhong-duan-dai-li/</id>
        <link href="https://dong1iu.github.io/post/mac-zhong-duan-dai-li/">
        </link>
        <updated>2021-05-19T07:00:16.000Z</updated>
        <content type="html"><![CDATA[<p>MAC下终端走代理的有多种方法</p>
<ol>
<li>临时代理</li>
</ol>
<p><code>export http_proxy='http://localhost:8001'</code></p>
<ol start="2">
<li>永久代理</li>
</ol>
<p>修改环境变量<br>
<code>vim ~/.zshrc</code></p>
<pre><code class="language-bash"># 添加以下内容
# proxy 
export http_proxy='http://localhost:8001'
export https_proxy='http://localhost:8001'
</code></pre>
<ol start="3">
<li>灵活开启</li>
</ol>
<p>修改环境变量<br>
<code>vim ~/.zshrc</code></p>
<pre><code># proxy
alias proxy='export all_proxy=&quot;http://localhost:8001&quot;' # 可在网络设置中查看
alias unproxy='unset all_proxy'
</code></pre>
<p>需要启用代理时，在终端输入<code>proxy</code>，关闭代理时，输入<code>unproxy</code>。</p>
<blockquote>
<p>检测是否成功代理</p>
</blockquote>
<p><code>curl cip.cc</code></p>
<p>或</p>
<p><code>curl ip.gs</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows同步MacOS鼠标滚轮自然]]></title>
        <id>https://dong1iu.github.io/post/windows-tong-bu-macos-shu-biao-gun-lun-zi-ran/</id>
        <link href="https://dong1iu.github.io/post/windows-tong-bu-macos-shu-biao-gun-lun-zi-ran/">
        </link>
        <updated>2021-05-19T05:04:55.000Z</updated>
        <content type="html"><![CDATA[<p>用习惯MAC系统偶尔要用用WINDOWS系统，或者由于各种原因总之时不时需要由MAC转向WIN系统或同时需要两个平台机器上倒腾来倒腾去的同学，一般来说最痛苦的就是鼠标滚轮方向不一致。</p>
<h1 id="第一步">第一步：</h1>
<p>计算机-右键-管理-系统工具-设备管理器-鼠标和其他指针设备-打开鼠标的属性-详细信息-属性-设备实例路径<br>
<img src="https://dong1iu.github.io/post-images/1623228426720.png" alt="" loading="lazy"></p>
<p>上面的值其实就是这个设置对应的注册表键值所在位置，我们要进行修改的时候也是根据这个来定位注册表的。</p>
<p>第二步：</p>
<p>点开始或者WIN键 R，输入：regedit 回车，然后就可以打开注册表编辑器了，然后按下面的描述定位注册表位置： HKEY_LOCAL_MACHINE \ SYSTEM - CurrentControlSet \ Enum \ ??? \ ??? \ ??? \ Device Parameters 找到 FlipFlopWheel字段 默认0，修改成1就变成了mac模式（简单来说就是改变了鼠标滚轮的方向）上面的???对应[设备实例路径]<br>
<img src="https://dong1iu.github.io/post-images/1623228440883.png" alt="" loading="lazy"></p>
<p>最后呢，重新插一下鼠标</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mac windows双系统的时间同步]]></title>
        <id>https://dong1iu.github.io/post/mac-windows-shuang-xi-tong-de-shi-jian-tong-bu/</id>
        <link href="https://dong1iu.github.io/post/mac-windows-shuang-xi-tong-de-shi-jian-tong-bu/">
        </link>
        <updated>2021-05-19T05:01:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>在windows管理员命令行中输入</strong></p>
<pre><code class="language-cmd">`Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1`
</code></pre>
<p>原因</p>
<p><strong>Windows 与 Mac缺省看待系统硬件时间的方式是不一样的</strong>：<br>
Windows把系统硬件时间当作本地时间(local time)，即操作系统中显示的时间跟BIOS中显示的时间是一样的。</p>
<p>Mac把硬件时间当作 UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8这样，当PC中同时有多系统共存时，就出现了问题。</p>
]]></content>
    </entry>
</feed>