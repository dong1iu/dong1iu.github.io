<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>动动栋栋</title>
    <updated>2021-06-15T09:16:16.511Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>南风知我意 吹梦到西洲</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2021, 动动栋栋</rights>
    <entry>
        <title type="html"><![CDATA[git教程]]></title>
        <id>http://localhost:4000/post/git-jiao-cheng/</id>
        <link href="http://localhost:4000/post/git-jiao-cheng/">
        </link>
        <updated>2021-06-15T08:58:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装git">安装GIT</h1>
<ol>
<li>安装homebrew</li>
<li>安装xcode</li>
</ol>
<h1 id="基础配置">基础配置</h1>
<p><code>git config —-global user.name &quot;Your name&quot;</code></p>
<p><code>git config -—global user.email &quot;yourEmail@example.com&quot;</code></p>
<p>查看设置是否成功</p>
<p><code>git config user.name</code></p>
<p>基本操作</p>
<p><code>add</code>、<code>commit</code></p>
<p>添加</p>
<p><code>git add &lt;file&gt;</code></p>
<p>提交</p>
<p><code>git commit -m &lt;message&gt;</code></p>
<h1 id="时光机">时光机</h1>
<p><code>git status</code></p>
<p>查看现在仓库的状态，会返回现在仓库哪些文件改动过和其他的信息</p>
<p><code>git diff</code></p>
<p>看得是**<code>工作区</code>**该文件与版本库中<code>当前分支</code>上该文件之间的差异</p>
<blockquote>
<p>严格地说，不一定，还可能是缓存区和仓库的区别，但在此处，我们简单的理解为上诉情况。</p>
</blockquote>
<ul>
<li>
<p>如何看懂<code>diff</code>的结果</p>
<pre><code class="language-bash">diff –-git a/f1 b/f1
index 8f86bb9..d74049c 100644
- a/f1
+++ b/f1
@@ -1,7 +1,7 @@  
code
code
code
-code
+code
code
code
code
</code></pre>
<ol>
<li><strong>第一行表示结果为git格式的diff</strong><code>diff --git a/f1 b/f1</code> 进行比较的是,a版本的f1(即变动前)和b版本的f1(即变动后)。</li>
<li><strong>第二行表示两个版本的git哈希值和最后的六位数字是对象的模式</strong><code>index 7a67204..8213f76 100644</code> index区域的7a67204对象,与工作目录区域的8213f76对象进行比较。<code>100</code>代表普通文件，<code>644</code>代表文件具有的权限（同linux文件权限）</li>
<li><strong>第三四行表示进行比较的两个文件</strong><code>a/f1+++ b/f1</code> &quot;-“表示变动前的版本，”+++&quot;表示变动后的版本。</li>
<li><strong>第五行表示代码变动的位置用两个@作为起首和结束</strong><code>@@ -1,7 +1,7 @@</code> &quot;-1,7″分成三个部分：减号表示第一个文件(即f1)，&quot;1″表示第1行，“7″表示连续7行。 合在一起，就表示下面是第一个文件从第1行开始的连续7行。 同样的，”+1,7″表示变动后，成为第二个文件从第1行开始的连续7行。</li>
<li><strong>第三部分是变动的具体内容</strong><code>code</code> 变动的行，上下文各显示3行。将两个文件上下文合并显示在一起。 每一行最前面的标志位：“-”代表第一个文件删除的行用红色表示，“+”表示第二个文件新增的行用绿色表示，无标志表示该行无变动。</li>
</ol>
</li>
</ul>
<p>提交修改的步骤</p>
<p>提交修改的步骤和添加文件的步骤是一样的</p>
<ol>
<li><code>git add modified_file_name</code></li>
<li><code>git commit -m &quot;comment&quot;</code></li>
</ol>
<h2 id="版本回退">版本回退</h2>
<h3 id="查看过去的版本">查看过去的版本</h3>
<p><code>git log -n 3 --pretty=oneline</code></p>
<p><code>-n 3</code> → 查看过去的三个版本</p>
<p><code>--pretty=oneline</code> → 美化结果为一行</p>
<p>如果希望以图的形式展示分支结构</p>
<p><code>--graph</code></p>
<ul>
<li>
<p>结果</p>
<pre><code class="language-bash"># 美化的
# commit_id ... comment
9cda832cca9f6c1cf77eae5afa42e3b5d7af3580 (HEAD -&gt; master) add version 3
272ad41ad60b17bd6e00506da5166953dcfc4ede add version 2
e245982e0e475d8a2c84209adaff560b7e42eadb add version 1

# 不美化的
commit 272ad41ad60b17bd6e00506da5166953dcfc4ede
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:51:24 2021 +0800

    add version 2

commit e245982e0e475d8a2c84209adaff560b7e42eadb
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:50:51 2021 +0800

    add version 1
dong1iu@IMAC-dong1iu gittest % git log -n 1
commit 9cda832cca9f6c1cf77eae5afa42e3b5d7af3580 (HEAD -&gt; master)
Author: dong1iu &lt;dong1iu@qq.com&gt;
Date:   Sun Jun 13 13:52:11 2021 +0800
</code></pre>
</li>
</ul>
<h3 id="回到过去的版本">回到过去的版本</h3>
<p><code>git reset --hard HEAD^</code></p>
<p><code>HEAD</code>指向的版本就是当前版本</p>
<h2 id="工作区-暂存区和库">工作区、暂存区和库</h2>
<p>⭐网络上很多博客关于这一部分的讲述都是不清晰的，我整理了廖雪峰git教程下网友的评论，以下是我认为正确的内容</p>
<h3 id="逻辑结构">逻辑结构</h3>
<ol>
<li>工作区（woking directory）</li>
<li>版本库
<ol>
<li>暂存区（stage or index）</li>
<li>库（head）</li>
</ol>
</li>
</ol>
<h3 id="添加过程">添加过程</h3>
<p><strong>注意：</strong><code>git</code>的任务是完成版本管理，所以在底层其实就是移动数据。</p>
<p>初始化完成后，三个区域都是空的</p>
<p>在编辑一个新的<code>readme.md</code>文件(v1)后，工作区会出现一个新的<code>untracked</code>文件，此时你<code>add</code>到缓存区，然后修改<code>readme.md</code>文件(v2)。到现在为止，你的工作区和缓存区很明显是不同的，指令<code>git diff</code>就是比较你的工作区和缓存区的不同。</p>
<p>现在，你在不add的情况下，直接将没有重新<code>add</code>的缓存区<code>commit</code>到你的库(<code>head</code>)，自然你的库中应该是保存的你第一次编辑的<code>readme.md</code>文件(v1)。注意，此时你的缓存区不是&quot;清空&quot;的状态，而是和<code>commit</code>前保持一样的状态，区别是你的缓存区和head的状态一致，所以<code>git status</code>提示你的<code>nothing to commit, working tree clean</code></p>
<p>那么如何比较你的工作区和库呢？答案是<code>git diff HEAD -- filename</code></p>
<h3 id="总结">总结</h3>
<p>比较工作区和缓存区 → <code>git diff</code></p>
<p>比较工作区和库 → <code>git diff HEAD -- filename</code></p>
<p>比较缓存区和库 → <code>git diff -cached</code></p>
<p>比较不同库版本 →<code>git diff 243550a 24bc01b</code> →<code>git diff commit_id1 commit_id2</code></p>
<p><code>git add</code>的<strong>逆</strong>操作 → <code>git checkout -- filename</code></p>
<p>注意：</p>
<ol>
<li><code>git add</code>本质是把暂存区的数据同步为工作区的数据，而checkout是将工作区的数据同步为stage中的数据。</li>
<li><code>--</code>不能少，<em><strong>有空格</strong></em>，不然命令会出错，变成了“切换到另一个分支”的命令，</li>
<li><code>git checkout --filename</code>在新版<code>git</code>中现在被<code>git restore</code>替代</li>
<li>原来的<code>git reset HEAD</code> 可以使用 <code>git restore --staged</code> 代替</li>
<li>原来的<code>git checkout branchName</code> 可以用 <code>git switch branchName</code> 代替。</li>
</ol>
<p>撤销<code>add</code> → <code>git restore --staged &lt;file&gt;...</code></p>
<p><code>unstage</code>操作，取消add操作</p>
<h2 id="删除文件">删除文件</h2>
<p>在工作区删除文件</p>
<p><code>rm filename</code></p>
<p>从库中删除文件</p>
<p><code>git rm filename</code></p>
<p><code>git commit -m &quot;delete filename&quot;</code></p>
<p>恢复被删除的文件</p>
<p><code>git restore filename</code>或<code>git checkout -- filename</code></p>
<p>原理上来说，缓存区的文件和版本库的文件是一致的，所以你可以从缓存区恢复你的文件。</p>
<h1 id="远程仓库">远程仓库</h1>
<h2 id="如何连接到你的远程仓库">如何连接到你的远程仓库</h2>
<ol>
<li>
<p>注册你的github账号</p>
</li>
<li>
<p>创建SSH key</p>
<p><code>ssh-keygen -t rsa -C &quot;youremial@example.com&quot;</code></p>
<p>一般在<code>用户主目录/.ssh</code>下，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，前者是私钥，后者是公钥。</p>
<p><em><strong>注意：千万不要丢失自己的私钥！！！</strong></em></p>
</li>
<li>
<p>添加公钥到github账号</p>
<p>Account settings → SSH and CPG keys → new ssh key</p>
</li>
</ol>
<h2 id="添加远程库">添加远程库</h2>
<h3 id="创建新的仓库">创建新的仓库</h3>
<p>在github仓库主页上 new repository</p>
<h3 id="关联本地仓库">关联本地仓库</h3>
<p><code>git remote add origin git@github.com:dong1iu/learngit.git</code></p>
<p>远程库的名字就是<code>origin</code></p>
<h3 id="推送">推送</h3>
<p><code>git push -u origin master</code></p>
<p>第一次时使用<code>-u</code>代表关联，把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支master推送到远程。以后可以简单是使用<code>git push origin master</code></p>
<p>notes: <code>-f</code>参数可以强制推送</p>
<h3 id="删除远程库连接">删除远程库连接</h3>
<p><code>git remote -v</code> → 查看远程库信息</p>
<p><code>git remote rm origin</code> → 删除本地仓库<strong>连接远程仓库</strong>（比如github上的learngit仓库）<strong>的连接。</strong></p>
<p>注意：</p>
<p><code>git push origin -d dev</code> → 删除远程数据库上的分支</p>
<h3 id="如何理解origin">如何理解Origin</h3>
<p>origin其实只是一个别名，按照我的理解，他是代表你本地仓库到远程仓库这个连接的名字。因为你push的时候需要知道你push到哪儿去了，所以你要指名这个连接，而完整的连接名太长，也不方便记忆和理解，所以使用origin来作为别称。另外，你从github上clone代码的时候，github会自动的把这个连接称为origin。</p>
<h2 id="从远程库克隆">从远程库克隆</h2>
<p><code>git clone git@github.com:dong1iu/gitskills.git</code></p>
<h1 id="分支管理">分支管理</h1>
<p>首先我们要明白git分支的工作原理</p>
<p>请参看廖雪峰分支管理</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点</p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1623747851195.png" alt="" loading="lazy"></figure>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上</p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1623747861961.png" alt="" loading="lazy"></figure>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1623747871215.png" alt="" loading="lazy"></figure>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1623747879062.png" alt="" loading="lazy"></figure>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1623747887057.png" alt="" loading="lazy"></figure>
<h2 id="创建和合并分支">创建和合并分支</h2>
<p>创建分支</p>
<p><code>git branch branchname</code></p>
<p>切换分支</p>
<p><code>git switch branchname</code></p>
<p>注意：当你切换分支时，HEAD的位置会变化，也就是说，你在某个分支上做的变化，在另一个分支上是看不到的</p>
<p>查看分支</p>
<p><code>git branch</code></p>
<pre><code class="language-sql">* dev
  master
</code></pre>
<p>星号代表当前HEAD所在分支</p>
<p>创建并切换分支</p>
<p><code>git switch -c branchname</code></p>
<p>合并某分支到当前分支</p>
<p><code>git merge branchname</code></p>
<p>删除分支</p>
<p><code>git branch -d branchname</code></p>
<p>删除远程上的分支</p>
<p><code>git push origin -d dev</code></p>
<h2 id="分支冲突">分支冲突</h2>
<p>在分支<code>master</code>和分支<code>dev</code>中分别修改<code>readme.md</code>的最后一行然后add并commit，merge的时候会发生冲突</p>
<p>此时处理的方式</p>
<ol>
<li>
<p>放弃merge</p>
<p><code>git merge --abort</code></p>
</li>
<li>
<p>修改冲突的文件并提交</p>
<ol>
<li>
<p><code>vim conflict_file</code></p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev
</code></pre>
</li>
<li>
<p><code>git add conflict_file</code></p>
</li>
<li>
<p><code>git commit -m &quot;merge conflict fixed&quot;</code></p>
</li>
</ol>
</li>
</ol>
<h2 id="分支策略">分支策略</h2>
<p>默认的情况下，git的merge采用fast forward策略，这种策略比较快，但是在改模式下，删除分支后会失去信息，使用<code>--no-ff</code>参数禁用fast forward策略</p>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1623747897906.png" alt="" loading="lazy"></figure>
<h1 id="标签管理">标签管理</h1>
<h2 id="创建标签">创建标签</h2>
<p>查看便签</p>
<p><code>git tag</code></p>
<p>添加便签</p>
<p><code>git tag &lt;name&gt;</code></p>
<p>给过去的<code>commit_id</code>添加标签</p>
<p><code>git tag &lt;name&gt; &lt;commit_id&gt;</code></p>
<p>查看已有的便签</p>
<p><code>git tag</code></p>
<p>查看标签信息</p>
<p><code>git show &lt;tag&gt;</code></p>
<p>其他说明</p>
<ol>
<li>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</li>
<li>标签不是按时间顺序列出，而是按字母排序的</li>
</ol>
<h2 id="操作标签">操作标签</h2>
<p>删除</p>
<p><code>git tag -d v0.1</code></p>
<p>推送某个标签</p>
<p><code>git push origin v1.0</code></p>
<h1 id="github">Github</h1>
<h2 id="查看当前的远程库">查看当前的远程库</h2>
<p>git remote -v</p>
<h2 id="提取远程仓库">提取远程仓库</h2>
<h3 id="从远程仓库下载新分支与数据">从远程仓库下载新分支与数据</h3>
<p><code>git fetch</code></p>
<h3 id="从远端仓库提取数据并尝试合并到当前分支">从远端仓库提取数据并尝试合并到当前分支</h3>
<p><code>git merge</code></p>
<h2 id="推送到远程仓库">推送到远程仓库</h2>
<p><code>git push -u origin master</code></p>
<h2 id="删除远程仓库中的分支">删除远程仓库中的分支</h2>
<p><code>git push origin -d dev</code> → 删除远程数据库上的分支</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[留存分析——Cohort分析]]></title>
        <id>http://localhost:4000/post/liu-cun-fen-xi-cohort-fen-xi/</id>
        <link href="http://localhost:4000/post/liu-cun-fen-xi-cohort-fen-xi/">
        </link>
        <updated>2021-06-09T08:59:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是cohort分析">什么是Cohort分析</h1>
<p>Cohort Analysis 可以翻译成 群体分析 或 分组分析，其实是一种通过细分来研究数据的方法。如下表就是一个从每日新增维度细分的 Cohort Analysis 表格。<br>
<img src="http://localhost:4000/post-images/1623229217530.png" alt="" loading="lazy"></p>
<h1 id="如何实现cohort分析">如何实现Cohort分析</h1>
<p>分组先分维度，再分粒度<br>
维度：你观察的用户分类，举例而言，注册账号的平台、设备、注册时间、性别等<br>
粒度：直白的说就是观察的间隔，比如以月、周、天、12小时等</p>
<h1 id="python实现cohort分析">python实现cohort分析</h1>
<h2 id="读取数据">读取数据</h2>
<ol>
<li>如果你的数据在数据库中，可以直接使用SQL查询</li>
<li>如果你的数据是冷数据，存放在文件中，可以用python直接读取，根据格式的不同使用不同的包，比如<code>pd.read_csv()</code></li>
</ol>
<h2 id="预处理数据">预处理数据</h2>
<p>根据既定的规则，处理数据。使用Pandas自带的函数等，例如map, apply, filter, 布尔索引等<br>
根据你的粒度，处理不同的生成新的时间列，可以命名为回访事件时间</p>
<h2 id="分组">分组</h2>
<p>使用<code>df.groupby(by=[...])</code>函数分组，和数据库中的group by异曲同工，不同的是，在Python中你可以轻易的进行数据透视，但是在SQL中相对比较复杂。当公司有稳健的数据库系统时，推荐使用SQL和Python结合的方式，即GROUPBY的工作由性能强大的数据库完成，数据透视由Python完成。</p>
<h2 id="数据透视">数据透视</h2>
<p>经过分组，我们等到的形如以下的结果</p>
<table>
<thead>
<tr>
<th>注册</th>
<th>注册时间</th>
<th>活跃</th>
<th>活跃时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>2020-01-01</td>
<td>A</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>B</td>
<td>2020-01-01</td>
<td>B</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>C</td>
<td>2020-01-01</td>
<td>C</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>A</td>
<td>2020-01-01</td>
<td>A</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>C</td>
<td>2020-01-01</td>
<td>C</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-02</td>
</tr>
<tr>
<td>B</td>
<td>2020-01-01</td>
<td>B</td>
<td>2020-01-03</td>
</tr>
<tr>
<td>D</td>
<td>2020-01-01</td>
<td>D</td>
<td>2020-01-03</td>
</tr>
</tbody>
</table>
<p>我们要完成的即一个数据透视工作，使用<code>pd.pivot_table()</code>完成</p>
<h1 id="代码参考">代码参考</h1>
<p>这里只给出主函数，因为函数的功能非常复杂，所以我们不细讲，只作为一个参考提供给大家</p>
<pre><code class="language-python">def gcohort(df, group_names, ncolumn='n', orient='倒三角', pre_filter=None, 
    init_event=None, init_agg={}, init_name=None,
    recall_event=None, recall_agg={}, recall_apply={},
    final_func=None, final_args=None):
    &quot;&quot;&quot;
    分群/对偶分析
    示例
        1.留存分析
            group_names = ['af_channel', 'country_code']
            trans_map = {'callback_time':'日期', 'af_channel':'渠道', 'country_code':'国家码'}
            
            gcohort(df, group_names, ncolumns='n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'},\
                init_name='激活', \
                recall_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                final_func=lambda x: x.rename(columns=trans_map))
        2. LTV计算
            # event_value_sum函数负责把event_value中的花费提取并加总，两个后处理函数分别负责补洞和累加和除
            ltv = gcohort(ddwwy, [], 'n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                init_name='激活', \
                recall_event='af_purchase', \
                recall_apply={'agg_func': event_value_sum, &quot;agg_args&quot;: {}}, \
                final_func=[
                    {&quot;func&quot;: fill_gcohort, &quot;kargs&quot;: {&quot;group_names&quot;: [], &quot;interval&quot;: '12h', &quot;orient&quot;: &quot;倒三角&quot;, &quot;time_col&quot;: &quot;时间&quot;}},  # 补洞
                    {&quot;func&quot;:ltv_cumsum_new, &quot;kargs&quot;: {&quot;time_col&quot;: &quot;时间&quot;, &quot;div_col&quot;:&quot;激活&quot;}},  # 累计LTV
                    ])
        3. 广告点击
            ltv = gcohort(ddwwy, [], 'n', orient='倒三角', \
                init_agg={'agg_column':'device_id', 'agg_method':'nunique'}, \
                init_name='激活', \
                recall_event='af_ad_click', \
                recall_agg={'agg_column':'device_id', 'agg_method':'count'}, \
                final_func=[
                    {&quot;func&quot;: fill_gcohort, &quot;kargs&quot;: {&quot;group_names&quot;: [], &quot;interval&quot;: '12h', &quot;orient&quot;: &quot;倒三角&quot;, &quot;time_col&quot;: &quot;时间&quot;}},  # 补洞
                    ])
        
    ----------
    Parameters
    ----------
    df : DataFrame.
        输入的源日志文件
    group_names : list.
        不包含时间和ncolumn的分组项
    ncolumn : str.
        时间差 取决于你分析表格的时间间隔列名字
    orient : str
        可选 ['正三角', '倒三角']
        orient决定回访事件分析是 是分群分析还是对偶分析
        
    pre_filter : func or list
        自定义的预处理函数 -&gt; 建议在此处对激活日期筛选
    init_evnet : str, list, func, DataFrame.
        可接受 [初始事件名, 初始事件字符串列表, 函数, 计算好的初始事件表]
    init_agg : dict
        init_event的聚合参数，需构造以下字典
        {
            &quot;agg_column&quot;: str. 聚合的列名,
            &quot;agg_method&quot;: str or func | 内置的字符串或自定义方法, 
        }
        注意：此参数只在init不是DataFrame类型时有效，即未输入计算好的初始事件表
    init_name : str. default is None
        聚合后初始事件列名
        
    recall_event : str, list or func. default is None
        召回事件
        当其为字符或字符串组成的列表时，从df中过滤事件 
    recall_agg : dict. default is {}
        召回事件的聚合参数 需构造以下字典
        列表的
            {
                &quot;agg_column&quot;: str. 聚合列名,
                &quot;agg_method&quot;: str or func. 聚合方法 支持agg内置的字符选项如 count sum nunique max等 也支持自定义func, 
                &quot;pivot_agg_method&quot;: str or func. 数据透视表的聚合方式 支持aggfunc内置字符如 sum first 也支持自定义func,
            }
        
    recall_apply : dict. default is {}
        召回事件的另一种聚合参数 需构造以下字典
            {
                &quot;agg_func&quot;: str. 聚合方法,
                &quot;agg_args&quot;: dict. 聚合方法的参数字典 (args), 
                &quot;pivot_agg_method&quot;: str or func. 数据透视表的聚合方式 支持aggfunc内置字符如 sum first 也支持自定义func,
            }

        recall = recall_df.groupby(k,...).agg({recall_agg[0], recall_agg[1]})
    final_func : func or list
        函数 字典 函数组成的列表 字典组成的列表 函数和字典混合组成的列表
        后处理函数或后处理函数列表
        例如
            1. 函数
                func = lambda x:x
            2. 字典
                {
                    &quot;func&quot;: add
                    &quot;kargs&quot;: {&quot;arg1&quot;: &quot;value1&quot;, &quot;arg2&quot;: &quot;value2&quot;}
                }
            3. 函数组成的列表
                [lambda x:x, lambda x:x, lambda x:x]
            ...
    &quot;&quot;&quot;
    # 资格审查
    if 'init_time' not in df.columns and 'callback_time' not in df.columns:
        print('源文件必须包含init_time和callback_time')
    
    # 源日志预处理 =========
    if callable(pre_filter):
        df = pre_filter(df)
    elif isinstance(pre_filter, list):
        for pf in pre_filter:
            df = pf(df)
    
    # 时间列判断
    # 初始事件时间 init_time, callback_time 此   这两个时间的粒度可以是月 周 天 小时等
    if orient == '正三角':
        time_col = 'callback_time'
        print('==对偶分析==')
    elif orient == '倒三角':
        time_col = 'init_time'
        print('==gcohort分析==')
    else:
        print(f'不可选的orient{orient}')
        return 
    
    # 初始事件 =============
    print('==处理初始事件==')
    # 初始事件准备
    init = None
    if init_event is None:
        init_df = df  # event为空时 默认具体
    elif isinstance(init_event, DataFrame):
        init = init_event  # 可接受计算好的初始事件表, 需要注意是输入的init_event必须和recall矩阵拥有相同的粒度和时间格式 否则表连接会错误
    elif isinstance(init_event, str):
        init_df = df[df.event_name==init_event]
    elif isinstance(init_event, list):
        init_df = df[df.event_name.isin(init_event)]
    elif callable(init_event):
        init_df = init_event(df)
    else:
        print(f'不支持的初始事件（init_event）参数：{init_event}')
        return
    # NOTE：对于激活事件 不建议在gcohort函数中聚合 
    #       因为源日志中的激活事件可能不齐全
    
    init_k = group_names + ['init_time']
    # 初始事件聚合
    if init is None:
        init = init_df.groupby(init_k, observed=True)\
            .agg({init_agg['agg_column']: init_agg['agg_method']})\
            .reset_index()\
            .rename(columns={init_agg['agg_column']:init_name})
    init = init.rename(columns={'init_time':'时间'})
    
    
    # 召回事件 =============
    print('==处理召回事件==')
    
    if recall_event is None:
        recall_df = df
    elif isinstance(recall_event, str):
        recall_df = df[df.event_name==recall_event]
    elif isinstance(recall_event, list):
        recall_df = df[df.event_name.isin(recall_event)]
    elif callable(recall_event):
        recall_df = recall_event(df)
    
    # 召回事件聚合
    if (recall_agg and recall_apply) or (not recall_agg and not recall_apply):
        print('recall_agg和recall_apply只可选其一')
        return
    
    pindex = group_names + [time_col]
    recall_k = pindex + [ncolumn]
    
    if recall_agg:
        aggfunc = recall_agg['pivot_agg_method'] if recall_agg.get('pivot_agg_method') else 'sum'
        recall = recall_df.groupby(recall_k, observed=True)\
            .agg({recall_agg['agg_column']:recall_agg['agg_method']})\
            .pivot_table(index=pindex, columns=ncolumn, values=recall_agg['agg_column'], aggfunc=aggfunc)\
            .reset_index()
    else:
        aggfunc = recall_apply['pivot_agg_method'] if recall_apply.get('pivot_agg_method') else 'sum'
        recall = recall_df.groupby(recall_k, observed=True) \
            .apply(recall_apply['agg_func'], recall_apply['agg_args']) \
            .reset_index() \
            .pivot_table(index=pindex, columns=ncolumn, values=0, aggfunc=aggfunc) \
            .reset_index()
            # values=0因为apply聚合后默认列名为0
    recall = recall.rename(columns={time_col: '时间'})
    
    # 连接初始表和召回表 =================================
    ans = init.merge(recall, on=group_names+['时间'], how='outer')
                
    # 后处理 ===============
    if callable(final_func):
        ans = final_func(ans)
    elif isinstance(final_func, dict):
        func = final_func.get(&quot;func&quot;)
        kargs = final_func.get(&quot;kargs&quot;)
        ans = func(ans, **kargs)
    elif isinstance(final_func, list):
        for afunc in final_func:
            if callable(afunc):
                ans = afunc(ans)
            if isinstance(afunc, dict):
                func = afunc.get(&quot;func&quot;)
                kargs = afunc.get(&quot;kargs&quot;)
                ans = func(ans, **kargs)
    # 补洞交由后处理函数函数 或 对返回的ans处理
    return ans
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在 Pandas DataFrame 中使用比较列表的问题]]></title>
        <id>http://localhost:4000/post/zai-pandas-dataframe-zhong-shi-yong-bi-jiao-lie-biao-de-wen-ti/</id>
        <link href="http://localhost:4000/post/zai-pandas-dataframe-zhong-shi-yong-bi-jiao-lie-biao-de-wen-ti/">
        </link>
        <updated>2021-06-01T08:21:50.000Z</updated>
        <content type="html"><![CDATA[<p>如果你经常尝试在DataFrame中存放列表并对列表进行过取等，你会发现结果这和你预想的不同</p>
<pre><code class="language-python">df = pandas.DataFrame([[1,2,3,[4,5]],[6,7,8,[9,10]]], columns=['a','b','c','d'])
&gt;&gt;&gt; df
   a  b  c        d
0  1  2  3   [4, 5]
1  6  7  8  [9, 10]
</code></pre>
<p>当你用d构建过滤器的时候</p>
<pre><code class="language-python">&gt;&gt;&gt; df['d'] == [4,5]
0    False
1    False
Name: d, dtype: bool
</code></pre>
<p><strong>造成这种现象的原因是，DataFrame中存储的列表不可哈希（散列）</strong><br>
如果你想正确的构建过滤器，你可以用一下方式</p>
<pre><code class="language-python">df.loc[:, 'd'].map(lambda x:x==[4,5])
</code></pre>
<p>这种方式调用匿名函数逐个比较，而不是使用哈希表比较，自然不会造成之前的错误</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu防火墙管理]]></title>
        <id>http://localhost:4000/post/ubuntu-fang-huo-qiang-guan-li/</id>
        <link href="http://localhost:4000/post/ubuntu-fang-huo-qiang-guan-li/">
        </link>
        <updated>2021-05-28T02:25:01.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>系统版本: ubuntu18.04</p>
</blockquote>
<h2 id="查看防火墙当前状态">查看防火墙当前状态</h2>
<p><code>sudo ufw status</code></p>
<h2 id="开启防火墙">开启防火墙</h2>
<blockquote>
<p>开启时请以前打开22端口的权限，否则无法ssh到机器</p>
</blockquote>
<p><code>sudo ufw enable</code></p>
<h2 id="ufw启用关闭重载">ufw启用/关闭/重载</h2>
<p><code>ufw enable/disable/reload</code></p>
<h2 id="允许外部访问80端口">允许外部访问80端口</h2>
<p><code>sudo ufw allow 80</code></p>
<h2 id="禁止外部访问80端口">禁止外部访问80端口</h2>
<p><code>sudo ufw delete allow 80</code></p>
<h2 id="允许此ip访问所有的本机端口">允许此IP访问所有的本机端口</h2>
<p><code>sudo ufw allow from 192.168.1.1</code></p>
<h2 id="禁止外部访问smtp服务">禁止外部访问smtp服务</h2>
<p><code>sudo ufw deny smtp</code></p>
<h2 id="安装ufw">安装ufw</h2>
<p><code>sudo apt-get install ufw</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac OS 时间机器全力备份]]></title>
        <id>http://localhost:4000/post/mac-os-shi-jian-ji-qi-quan-li-bei-fen/</id>
        <link href="http://localhost:4000/post/mac-os-shi-jian-ji-qi-quan-li-bei-fen/">
        </link>
        <updated>2021-05-26T05:03:46.000Z</updated>
        <content type="html"><![CDATA[<p>全力备份</p>
<p><code>sudo sysctl debug.lowpri_throttle_enabled=0</code></p>
<p>静默备份</p>
<p><code>sudo sysctl debug.lowpri_throttle_enabled=1</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python数据规整化：清理、转换、合并、重塑]]></title>
        <id>http://localhost:4000/post/python-shu-ju-gui-zheng-hua-qing-li-zhuan-huan-he-bing-chong-su/</id>
        <link href="http://localhost:4000/post/python-shu-ju-gui-zheng-hua-qing-li-zhuan-huan-he-bing-chong-su/">
        </link>
        <updated>2021-05-19T08:30:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="合并数据集">合并数据集</h1>
<h2 id="数据库风格的合并">数据库风格的合并</h2>
<pre><code class="language-python">pd.merge(df1, df2, on='key')
# 如果列的名字不同
pd.merge(df1, df2, left_on='key1', right_on='key2')
# how= inner left right outter
pd.merge(df1, df2, on='key', how='innner')

</code></pre>
<p>多对多连接时产生的时行的笛卡尔积</p>
<p>要根据多个键合并时，传入一个由列名组成的列表即可</p>
<pre><code class="language-python">pd.merge(df1, df2, on=['key1', 'key2'], how='innner')
</code></pre>
<p>注意在进行列连接时，DataFrame对象中的索引会被丢弃</p>
<p>对重复列名的处理</p>
<pre><code class="language-python">pd.merge(left, right, on='key', suffixes=('_left', '_right')
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1623227523966.png" alt="" loading="lazy"></figure>
<p>完整参数<br>
<img src="http://localhost:4000/post-images/1623227533897.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1623227537948.png" alt="" loading="lazy"></figure>
<h2 id="索引上的合并">索引上的合并</h2>
<pre><code>如果连接键位于起索引中，可传入left_index=True或right_index=True(或都传)以说明索引应该被用作连接键

```python
pd.merge(left, right, left_on='key', right_index=True)
```

对于层次化索引， 比较复杂
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://localhost:4000/post-images/1623227546081.png" alt="" loading="lazy"></figure>
<pre><code>必须以列表的形式指明用作合并键的多个列

```python
pd.merge(left, right, left_on=['key1, key2'], right_index=True)
```

join实例方法 df.join

默认左连接

```python
left.join(right, on='key', how='inner')
```
</code></pre>
<h1 id="轴向连接">轴向连接</h1>
<h2 id="concat">concat</h2>
<p>可称为连接（concatenation）、绑定（binding）或堆叠（stacking）</p>
<p>concatenation 用于合并原始Numpy数组<br>
<img src="http://localhost:4000/post-images/1623227551979.png" alt="" loading="lazy"></p>
<pre><code class="language-python">np.concatenate([arr, arr], axis=1)
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://localhost:4000/post-images/1623227556829.png" alt="" loading="lazy"></figure>
<p>对于pandas对象，带有标签的轴使你能够进一步推广数组的连接，所以concatenate的可用性就不高了</p>
<p>使用CONCAT函数</p>
<pre><code class="language-python"># 带标签
pd.concat([s1, s2, s3])
# 默认axis=0
pd.concat([df1, df2, df3], axis=0)
</code></pre>
<p>参数join</p>
<pre><code class="language-python"># 舍弃 两个Series中不共有的位置
pd.concat([s1, s2], axis=0, join='inner')
</code></pre>
<p>参数joinaxes 指定在其他轴上使用的索引</p>
<pre><code class="language-python">pd.concat([s1, s2], axis=0, join_axes=[['a', 'b'])
</code></pre>
<p>参数keyx 用于区分连接的结果</p>
<pre><code class="language-python">In [70]: result = pd.concat([s1,s2,s3], keys=['one', 'two','three'])
Out[70]: result
one    a  0
        b  1
two    a  0
                b  1
three  f  5
        g  6
</code></pre>
<p>如果沿着axis=1对Series进行合并，这keys会成为DataFrame的列头</p>
<p>如果keys传入的不是列表而是字典，那么字典的键会被当做keys选项的值</p>
<p>处理和分析工作无关的index</p>
<pre><code class="language-python">pd.concat([df1, df2], ingore_indexx=True)
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://localhost:4000/post-images/1623227564113.png" alt="" loading="lazy"></figure>
<h2 id="合并重叠数据">合并重叠数据</h2>
<p>使用np.where重叠</p>
<pre><code class="language-python">np.where(pd.isnull(a), b, a)
</code></pre>
<p>使用combine_first</p>
<pre><code class="language-python">b[:2].combine_first(a[:])
</code></pre>
<p>##重塑和轴向旋转</p>
<p>重塑层次化索引</p>
<p>stack和unstack方法分别将数据的列旋转为行、将数据的行旋转为列</p>
<p>STACK方法<br>
<img src="http://localhost:4000/post-images/1623227569712.png" alt="" loading="lazy"></p>
<pre><code class="language-python">data.stack()
</code></pre>
<figure data-type="image" tabindex="6"><img src="http://localhost:4000/post-images/1623227574396.png" alt="" loading="lazy"></figure>
<p>UNSTACK方法<br>
<img src="http://localhost:4000/post-images/1623227579478.png" alt="" loading="lazy"></p>
<p>默认情况unstack操作的是最内层（同stack）。可以传入级别的编号和名称</p>
<pre><code class="language-python">result.unstack(0)
result.unstack('state')
</code></pre>
<p>如果不是所有级别值都能在个分组中找到的话，这unstack操作会引入NAN，而stack()方法默认会过滤缺失值，所以两方法是可逆的</p>
<h2 id="将长表转换为宽表">将长表转换为宽表</h2>
<figure data-type="image" tabindex="7"><img src="http://localhost:4000/post-images/1623227586212.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.pivot('date', 'item', 'value')
</code></pre>
<p>前两个参数分别作为行列索引的列名，最后一个是填充DF数据列名的。<br>
<img src="http://localhost:4000/post-images/1623227592594.png" alt="" loading="lazy"></p>
<p>如果有两个需要参与重塑的数据列</p>
<pre><code class="language-python">pivoted = df.pivo('date', 'item')
# 忽略最后一个参数得到的DF就会带有层次化的列
</code></pre>
<figure data-type="image" tabindex="8"><img src="http://localhost:4000/post-images/1623227597553.png" alt="" loading="lazy"></figure>
<p>注意pivot其实只是一个快捷方式：实质上用set_index创建层次化soyb，再用unstack重塑。</p>
<h1 id="移除重复数据">移除重复数据</h1>
<p>duplicated 方法 返回一个布尔型Series</p>
<pre><code class="language-python">data.duplicated()
</code></pre>
<p>drop_duplicates() 默认只保留第一行</p>
<pre><code class="language-python">df.drop_duplicates(subset=['a', 'b'], keep='first', inplace=False, ingore_index=False)
# - first : Drop duplicates except for the first occurrence. - last : Drop duplicates except for the last occurrence. - False : Drop all duplicates.
# If True, the resulting axis will be labeled 0, 1, …, n - 1.
</code></pre>
<h1 id="使用函数或映射进行数据装换">使用函数或映射进行数据装换</h1>
<p>Series的map方法可以接受一个函数或含有映射关系的字典型对象</p>
<pre><code class="language-python"># meat_to_animal是一个字典
data['animal'] = data['food'].map(str.lower).map(meat_to_animal)
</code></pre>
<p>也可以传入完整的数据</p>
<pre><code class="language-python">data['animal'] = data['food'].map(lambda x: meat_to_animal[x.lower()])
</code></pre>
<h1 id="替换值">替换值</h1>
<p>replace 函数</p>
<pre><code class="language-python">data.place([-999, -1000], np.nan)
</code></pre>
<p>也可以传入字典</p>
<pre><code class="language-python">data.replace({-999:np.nan, -1000:0})
</code></pre>
<h1 id="重命名轴索引">重命名轴索引</h1>
<p>和Series一样，轴标签也有一个map方法</p>
<pre><code class="language-python">data.index.map(str.upper)
</code></pre>
<p>rename 方法</p>
<pre><code class="language-python">df.rename(index=str.title, columns=str.upper)
</code></pre>
<p>也可以传入字典修改</p>
<h1 id="离散化和面元bin划分">离散化和面元（bin）划分</h1>
<p>cut方法</p>
<pre><code class="language-python">bins = [18, 25, 35, 60, 100]
cats = pd.cut(ages, bins)
</code></pre>
<p>pandas会返回特殊的Categorical对象，他实际上是表示不同分类名称的levels数组以及一个为年龄数据进行标号的labels属性</p>
<pre><code class="language-python">In [157]: cats.labels 
Out[157]: array([o, o, o, 1, o, o, 2, 1, 3, 2, 2, 1]) 
In (158]: cats.levels 
Out[158]: Index([(18, 25], (25, 35], (35, 60], (60, 100]], dtype=object) 
In [159]: pd.value_counts(cats) 
Out[159]:
(18, 25]    5
(35, 60]    3
(25, 35]    3 
(60, 100]   1
</code></pre>
<p>right参数 修改区间的取向</p>
<pre><code class="language-python"># right不取右边
pd.cut(ages, bins, right=False)
</code></pre>
<p>label参数 设置自己分箱名称</p>
<pre><code class="language-python">pd.cut(ages, labels=['Youth', 'YoungAdult', ...])
</code></pre>
<p>如果传入的分箱的数量而不是确切的临界值，则他会根据数据的最小值和最大值计算等距分箱</p>
<pre><code class="language-python">pd.cut(data, 4, precision=2)
</code></pre>
<p>QCUT</p>
<p>根据样本的分位数进行分箱</p>
<pre><code class="language-python">pd.qcut(data, 4)
# 也可以自己设置
pd.qcut(data, [o, 0.1, o.s, 0.9, 1.))
</code></pre>
<h1 id="检测和过滤异常值">检测和过滤异常值</h1>
<p>找出绝对值大小超过3的值</p>
<pre><code class="language-python">col[np.abs(col) &gt; 3]
</code></pre>
<p>选出全部含有“超过3或-3的值”的行，使用any方法</p>
<pre><code class="language-python">data[(np.abs(data) &gt; 3).any(1)]
</code></pre>
<p>将df中的值重新限制到-3到3之间</p>
<pre><code class="language-python">data[np.abs(data) &gt; 3] = np.sign(data) * 3
</code></pre>
<h1 id="排列和随机采样">排列和随机采样</h1>
<p>利用numpy.random.permutation函数可以轻松实现对Series或DataFrame的列的排列工作（permuting）。通过需要排列的轴长度调用permutation，可以产生一个表示新顺序的整数数组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MAC终端代理]]></title>
        <id>http://localhost:4000/post/mac-zhong-duan-dai-li/</id>
        <link href="http://localhost:4000/post/mac-zhong-duan-dai-li/">
        </link>
        <updated>2021-05-19T07:00:16.000Z</updated>
        <content type="html"><![CDATA[<p>MAC下终端走代理的有多种方法</p>
<ol>
<li>临时代理</li>
</ol>
<p><code>export http_proxy='http://localhost:8001'</code></p>
<ol start="2">
<li>永久代理</li>
</ol>
<p>修改环境变量<br>
<code>vim ~/.zshrc</code></p>
<pre><code class="language-bash"># 添加以下内容
# proxy 
export http_proxy='http://localhost:8001'
export https_proxy='http://localhost:8001'
</code></pre>
<ol start="3">
<li>灵活开启</li>
</ol>
<p>修改环境变量<br>
<code>vim ~/.zshrc</code></p>
<pre><code># proxy
alias proxy='export all_proxy=&quot;http://localhost:8001&quot;' # 可在网络设置中查看
alias unproxy='unset all_proxy'
</code></pre>
<p>需要启用代理时，在终端输入<code>proxy</code>，关闭代理时，输入<code>unproxy</code>。</p>
<blockquote>
<p>检测是否成功代理</p>
</blockquote>
<p><code>curl cip.cc</code></p>
<p>或</p>
<p><code>curl ip.gs</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows同步MacOS鼠标滚轮自然]]></title>
        <id>http://localhost:4000/post/windows-tong-bu-macos-shu-biao-gun-lun-zi-ran/</id>
        <link href="http://localhost:4000/post/windows-tong-bu-macos-shu-biao-gun-lun-zi-ran/">
        </link>
        <updated>2021-05-19T05:04:55.000Z</updated>
        <content type="html"><![CDATA[<p>用习惯MAC系统偶尔要用用WINDOWS系统，或者由于各种原因总之时不时需要由MAC转向WIN系统或同时需要两个平台机器上倒腾来倒腾去的同学，一般来说最痛苦的就是鼠标滚轮方向不一致。</p>
<h1 id="第一步">第一步：</h1>
<p>计算机-右键-管理-系统工具-设备管理器-鼠标和其他指针设备-打开鼠标的属性-详细信息-属性-设备实例路径<br>
<img src="http://localhost:4000/post-images/1623228426720.png" alt="" loading="lazy"></p>
<p>上面的值其实就是这个设置对应的注册表键值所在位置，我们要进行修改的时候也是根据这个来定位注册表的。</p>
<p>第二步：</p>
<p>点开始或者WIN键 R，输入：regedit 回车，然后就可以打开注册表编辑器了，然后按下面的描述定位注册表位置： HKEY_LOCAL_MACHINE \ SYSTEM - CurrentControlSet \ Enum \ ??? \ ??? \ ??? \ Device Parameters 找到 FlipFlopWheel字段 默认0，修改成1就变成了mac模式（简单来说就是改变了鼠标滚轮的方向）上面的???对应[设备实例路径]<br>
<img src="http://localhost:4000/post-images/1623228440883.png" alt="" loading="lazy"></p>
<p>最后呢，重新插一下鼠标</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mac windows双系统的时间同步]]></title>
        <id>http://localhost:4000/post/mac-windows-shuang-xi-tong-de-shi-jian-tong-bu/</id>
        <link href="http://localhost:4000/post/mac-windows-shuang-xi-tong-de-shi-jian-tong-bu/">
        </link>
        <updated>2021-05-19T05:01:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>在windows管理员命令行中输入</strong></p>
<pre><code class="language-cmd">`Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1`
</code></pre>
<p>原因</p>
<p><strong>Windows 与 Mac缺省看待系统硬件时间的方式是不一样的</strong>：<br>
Windows把系统硬件时间当作本地时间(local time)，即操作系统中显示的时间跟BIOS中显示的时间是一样的。</p>
<p>Mac把硬件时间当作 UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8这样，当PC中同时有多系统共存时，就出现了问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[感知机PLA]]></title>
        <id>http://localhost:4000/post/gan-zhi-ji-pla/</id>
        <link href="http://localhost:4000/post/gan-zhi-ji-pla/">
        </link>
        <updated>2021-05-11T10:47:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pla-感知机">PLA 感知机</h1>
<h1 id="一-the-learning-problem">一、The Learning Problem</h1>
<p>本质</p>
<ol>
<li>存在某种现在的模式去学习（so performance measure can be improved）</li>
<li>不能被简单定义（so ML is needed）</li>
<li>there is data about the pattern</li>
</ol>
<h1 id="二-perceptron-learning-algorithmpla">二、Perceptron Learning Algorithm（PLA）</h1>
<p>图示<br>
<img src="http://localhost:4000/post-images/1623062895684.png" alt="" loading="lazy"></p>
<h2 id="一线形可分">（一）线形可分</h2>
<p>图总第一个为线性可分，经典的PLA只能处理完全线性可分的类型。<br>
<img src="http://localhost:4000/post-images/1623062905822.png" alt="" loading="lazy"></p>
<h2 id="二感知机算法图解">（二）感知机算法图解</h2>
<p>图解<br>
<img src="http://localhost:4000/post-images/1623062913237.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1623062919845.png" alt="" loading="lazy"></figure>
<h2 id="三如何选择g">（三）如何选择g</h2>
<p>迭代w<br>
<img src="http://localhost:4000/post-images/1623062935084.png" alt="" loading="lazy"></p>
<p>从某些初始值开始，一步步迭代到损失最小</p>
<h2 id="四迭代更新">（四）迭代更新</h2>
<p>图示<br>
<img src="http://localhost:4000/post-images/1623062941847.png" alt="" loading="lazy"></p>
<p>误分类 → <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mo>(</mo><msubsup><mi>w</mi><mi>t</mi><mi>T</mi></msubsup><msub><mi>x</mi><mrow><mi>n</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msub><mo>)</mo><mi mathvariant="normal">≠</mi><msub><mi>y</mi><mrow><mi>n</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">sign(w_t^Tx_{n(t)})\neq{y_{n(t)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1965309999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span> → 更新步 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>w</mi><mi>t</mi></msub><mo>+</mo><msub><mi>y</mi><mrow><mi>n</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msub><msub><mi>x</mi><mrow><mi>n</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">w_{t+1}=w_t+y_{n(t)}x_{n(t)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>证明<br>
<img src="http://localhost:4000/post-images/1623062950108.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1623062957694.png" alt="" loading="lazy"></figure>
<p>w的更新意味着分类超平面的移动</p>
<h2 id="五-收敛性证明">（五）、收敛性证明</h2>
<p>我们已经知道更新w向量方法，但是，这样的更新方法是否收敛？</p>
<p>证明过程</p>
<ol>
<li>
<p>假设线形可分的数据集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span></span>能被向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">w_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>完美划分</p>
<p>因此<br>
<img src="http://localhost:4000/post-images/1623062968114.png" alt="" loading="lazy"></p>
<p>从而<br>
<img src="http://localhost:4000/post-images/1623062976143.png" alt="" loading="lazy"></p>
</li>
<li>
<p>更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">w_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>意味着发生了错误，也就是<br>
<img src="http://localhost:4000/post-images/1623062983717.png" alt="" loading="lazy"></p>
<p>从而<br>
<img src="http://localhost:4000/post-images/1623062989593.png" alt="" loading="lazy"></p>
</li>
<li>
<p>证明<br>
<img src="http://localhost:4000/post-images/1623062996830.png" alt="" loading="lazy"></p>
<p>证明过程<br>
<img src="http://localhost:4000/post-images/1623063003431.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>收敛性的说明</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>(</mo><mi>T</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msubsup><mi>w</mi><mi>f</mi><mi>T</mi></msubsup><msub><mi>w</mi><mi>T</mi></msub></mrow><mrow><mo>∥</mo><msub><mi>w</mi><mi>f</mi></msub><mo>∥</mo><mo>⋅</mo><mo>∥</mo><msub><mi>w</mi><mi>T</mi></msub><mo>∥</mo></mrow></mfrac><mo>≥</mo><msqrt><mi>T</mi></msqrt><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>t</mi><mo>=</mo><mi>ρ</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">cos\theta(T) = \frac{w_f^Tw_T}{\lVert w_f \lVert \cdot \lVert w_T \lVert} \geq \sqrt{T}\cdot constant=\rho/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.798865em;vertical-align:-0.5480799999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.250785em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">∥</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span><span class="mopen mtight">∥</span><span class="mord mtight">⋅</span><span class="mopen mtight">∥</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span><span class="mopen mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.60742em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.214em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.42488571428571426em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5480799999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ρ</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><br>
<img src="http://localhost:4000/post-images/1623063013335.png" alt="" loading="lazy"></p>
<ol>
<li>线性可分告诉我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>w</mi><mi>f</mi><mi>T</mi></msubsup><msub><mi>w</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">w_f^Tw_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在增长</li>
<li>错误修正的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>告诉我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">w_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的模长存在上界</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>w</mi><mi>f</mi><mi>T</mi></msubsup><msub><mi>w</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">w_f^Tw_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2605469999999999em;vertical-align:-0.4192159999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4192159999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的增长一部分依赖<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">cos(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>的增长<br>
<img src="http://localhost:4000/post-images/1623063021508.png" alt="" loading="lazy"></li>
</ol>
<h1 id="三-其他pla">三、其他PLA</h1>
<p>Pocket PLA:非线性可分数据的感知器<br>
<img src="http://localhost:4000/post-images/1623063030248.png" alt="" loading="lazy"></p>
<p>优点：可以对近似线形可分的数据集进行处理</p>
<p>缺点：计算量大，每次都要计算所有的点</p>
]]></content>
    </entry>
</feed>