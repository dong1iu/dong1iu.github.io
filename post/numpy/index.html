<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Numpy | 动动栋栋</title>
<link rel="shortcut icon" href="https://dong1iu.github.io/favicon.ico?v=1623228597094">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dong1iu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Numpy | 动动栋栋 - Atom Feed" href="https://dong1iu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。⼤多数提供科学计算的包都是⽤NumPy的数组作为构建基础。
介绍
NumPy之于数值计算特别重要的原因之⼀，是因为它可以⾼效处理⼤数组的数据。这是因为..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dong1iu.github.io">
  <img class="avatar" src="https://dong1iu.github.io/images/avatar.png?v=1623228597094" alt="">
  </a>
  <h1 class="site-title">
    动动栋栋
  </h1>
  <p class="site-description">
    南风知我意 吹梦到西洲
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dong1iu.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Numpy
            </h2>
            <div class="post-info">
              <span>
                2021-06-07
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://dong1iu.github.io/tag/EDcNg_R0it/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。⼤多数提供科学计算的包都是⽤NumPy的数组作为构建基础。</p>
<h1 id="介绍">介绍</h1>
<p>NumPy之于数值计算特别重要的原因之⼀，是因为它可以⾼效处理⼤数组的数据。这是因为：</p>
<p>NumPy是在⼀个连续的内存块中存储数据，独⽴于其他Python内置对象。NumPy的C语⾔编写的算法库可以操作内存，⽽不必进⾏类型检查或其它前期⼯作。⽐起Python的内置序列，NumPy数组使⽤的内存更少。<br>
NumPy可以在整个数组上执⾏复杂的计算，⽽不需要Python的for循环。</p>
<p><strong>总而言之，numpy比list快，而且内存使用更少。</strong></p>
<h1 id="一-ndarray">一、 ndarray</h1>
<ol>
<li>
<p>**创建ndarray （**ones zeros empty ）</p>
<pre><code class="language-python">data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
# array([ 6. ,  7.5,  8. ,  0. ,  1. ])

data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
# array([[1, 2, 3, 4],
#         5, 6, 7, 8]])
</code></pre>
<p>除非特别说明，np.array会尝试为新建的这个数组推断出⼀个较为合适的数据类型。数据类型保存在⼀个特殊的dtype对象中。</p>
<pre><code class="language-python">In [27]: arr1.dtype
Out[27]: dtype('float64')
</code></pre>
<p><strong>使用其他函数创建数组</strong></p>
<p>ones zeros empty</p>
<pre><code class="language-python">zeros和ones分别可以创建指定⻓度或形状的全0或全1数组。
# zeros
In [29]: np.zeros(10)
Out[29]: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
In [30]: np.zeros((3, 6))

</code></pre>
<p>注意：用np.empty()创建0数组是不安全的，它返回的都是⼀些未初始化的垃圾值。即可能是float和int混杂的数组。</p>
<p>arrange</p>
<pre><code class="language-python">In [32]: np.arange(15)
Out[32]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623039515523.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p><strong>ndarray的数据类型 （<strong>astype</strong>）</strong></p>
<p>为ndarray<strong>指定数据类型</strong></p>
<pre><code class="language-python">arr1 = np.array([1, 2, 3], dtype=np.float64)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623039534839.png" alt="" loading="lazy"></figure>
<p><strong>转换dtype</strong></p>
<pre><code class="language-python">float_arr = arr.astype(np.float64)
</code></pre>
<p>如果某字符串数组表示的全是数字，也可以⽤astype将其转换为数值形式</p>
<pre><code class="language-python">In [44]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string)
In [45]: numeric_strings.astype(float
</code></pre>
<p>如果转换过程因为某种原因⽽失败了（⽐如某个不能被转换为float64的字符串），就会引发⼀个ValueError</p>
<p>可以引用别的数组的属性来修改你想要的属性</p>
<pre><code class="language-python">In [48]: int_array.astype(calibers.dtype)
</code></pre>
</li>
<li>
<p><strong>NumPy数组的运算</strong></p>
<p>数组很重要，因为它使你不⽤编写循环即可对数据执⾏批量运算。NumPy⽤户称其为⽮量化（vectorization）。⼤⼩相等的数组之间的任何算术运算都会将运算应⽤到元素级</p>
<pre><code class="language-python">arr * arr
arr - arr
</code></pre>
<p>数组与标量的算术运算会将标量值传播到各个元素</p>
<pre><code class="language-python">In [55]: 1 / arr
In [56]: arr ** 0.5
</code></pre>
<p>⼤⼩相同的数组之间的⽐较会⽣成布尔值数组</p>
<pre><code class="language-python">In [59]: arr2 &gt; arr
Out[59]:
array([[False,  True, False],
			[ True, False,  True]], dtype=bool)
</code></pre>
</li>
<li>
<p><strong>⼴播（broadcasting）</strong></p>
<p>不同⼤⼩的数组之间的运算叫做⼴播（broadcasting）</p>
</li>
<li>
<p><strong>基本的索引和切⽚</strong></p>
<p><strong>一维数组</strong></p>
<pre><code class="language-python">In [63]: arr[5:8]
Out[63]: array([5, 6, 7])
</code></pre>
<p>当你将⼀个标量值赋值给⼀个切⽚时（如arr[5:8]=12），该值会⾃动传播，而且这张赋值是会直接改变原数列的。</p>
<p><strong>⾼维度数组</strong></p>
<p>对于⾼维度数组，能做的事情更多。在⼀个⼆维数组中，各索引位置上的元素不再是标量⽽是⼀维数组。</p>
<pre><code class="language-python">In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
In [73]: arr2d[2]
Out[73]: array([7, 8, 9])
</code></pre>
<p>可以传⼊⼀个以逗号隔开的索引列表来选取单个元素。下⾯两种⽅式是等价的：</p>
<pre><code class="language-python">In [74]: arr2d[0][2] 
Out[74]: 3
In [75]: arr2d[0, 2] 
Out[75]: 3
</code></pre>
<p>在2×2×3数组arr3d中：arr3d[0]是⼀个2×3数组：</p>
<pre><code class="language-python">In [76]: arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
In [77]: arr3d
Out[77]: 
array([[[ 1,  2,  3],
			[ 4,  5,  6]],
			[[ 7,  8,  9],
			[10, 11, 12]]])
In [78]: arr3d[0] 
Out[78]: 
array([[1, 2, 3],
			[4, 5, 6]])
</code></pre>
<p>标量值和数组都可以被赋值给arr3d[0]：标志值会广播</p>
<figure data-type="image" tabindex="3"><img src="https://dong1iu.github.io/post-images/1623039560105.png" alt="" loading="lazy"></figure>
</li>
<li>
<p><strong>切片索引</strong></p>
<p>一维和列表差不多</p>
<pre><code class="language-python">In [89]: arr[1:6]
Out[89]: array([ 1,  2,  3,  4, 64])
</code></pre>
<p>对于之前的⼆维数组arr2d，其切⽚⽅式稍显不同：</p>
<pre><code class="language-python"># 只输入一个参数时，优先axis0切片
In [92]: arr2d[:2, 1:] 
Out[92]: 
array([[2, 3],
			[5, 6]])
</code></pre>
<p>通过将整数索引和切⽚混合，可以得到低维度的切⽚，例如arr2d[1, :2]和arr2d[:2, 2]。</p>
<figure data-type="image" tabindex="4"><img src="https://dong1iu.github.io/post-images/1623039570171.png" alt="" loading="lazy"></figure>
<p>⾃然，对切⽚表达式的赋值操作也会被扩散到整个选区：</p>
</li>
<li>
<p><strong>布尔型索引</strong></p>
<pre><code class="language-python">In [100]: names
Out[100]: 
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],

In [101]: data 
Out[101]: array(7X4)

In [103]: data[names == 'Bob']
Out[103]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
			[ 1.669 , -0.4386, -0.5397,  0.477 ]])
</code></pre>
<p>布尔型数组的⻓度必须跟被索引的轴⻓度⼀致。此外，还可以将布尔型数组跟切⽚、整数（或整数序列）混合使⽤：</p>
<pre><code class="language-python">In [104]: data[names == 'Bob', 2:]
</code></pre>
<p>要选择除&quot;Bob&quot;以外的其他值，既可以使⽤不等于符号（!=），也可以通过<sub>对条件进⾏否定，</sub>操作符⽤来反转条件很好⽤：</p>
<pre><code class="language-python">In [106]: names != 'Bob'
In [107]: data[~(names == 'Bob')]
</code></pre>
<p>选取这三个名字中的两个需要组合应⽤多个布尔条件，使⽤&amp;（和） |（或）之类的布尔算术运算符即可：</p>
<pre><code class="language-python">In [110]: mask = (names == 'Bob') | (names == 'Will')
</code></pre>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回⼀模⼀样的数组也是如此。</p>
<p>通过布尔型数组设置值是⼀种经常⽤到的⼿段。</p>
<p>将data中的所有负值都设置为0</p>
<pre><code class="language-python">In [113]: data[data &lt; 0] = 0
</code></pre>
</li>
<li>
<p><strong>花式索引</strong></p>
<p>花式索引（Fancy indexing）是⼀个NumPy术语，它指的是利⽤整数数组进⾏索引。</p>
<p>为了以特定顺序选取⾏⼦集，只需传⼊⼀个⽤于指定顺序的整数列表或ndarray即可：</p>
<figure data-type="image" tabindex="5"><img src="https://dong1iu.github.io/post-images/1623039580571.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://dong1iu.github.io/post-images/1623039586105.png" alt="" loading="lazy"></figure>
<p>这段代码确实达到我们的要求了！使⽤负数索引将会从末尾开始选取⾏：</p>
<pre><code class="language-python">In [121]: arr[[-3, -5, -7]]
</code></pre>
<p>⼀次传⼊多个索引数组会有⼀点特别。它返回的是⼀个⼀维数组，其中的元素对应各个索引元组：</p>
<pre><code class="language-python">In [124]: arr[[1, 5, 7, 2], [0, 3, 1, 2]] 
Out[124]: array([ 4, 23, 29, 10])
# 最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。⽆论数组是多少维的，花式索引总是⼀维的。
</code></pre>
<p>这个花式索引的⾏为可能会跟某些⽤户的预期不⼀样（包括我在内），选取矩阵的⾏列⼦集应该是矩形区域的形式才对。下⾯是得到该结果的⼀个办法：</p>
<pre><code class="language-python">In [125]: arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]] 
Out[125]: 
array([[ 4,  7,  5,  6],
			[20, 23, 21, 22],
			[28, 31, 29, 30],
			[ 8, 11,  9, 10]])
# 最终选出的是元素(1,0)、(1,3)、(1,1)和(1,2)
# 最终选出的是元素(5,0)、(5,3)、(5,1)和(5,2)
# ...
</code></pre>
</li>
<li>
<p><strong>数组转置和轴对换</strong></p>
<p>转置是重塑的⼀种特殊形式，它返回的是源数据的视图（不会进⾏任何复制操作）。数组不仅有transpose⽅法，还有⼀个特殊的T属性：</p>
<p>在进⾏矩阵计算时，经常需要⽤到该操作，⽐如利⽤np.dot计算矩阵内积：</p>
<pre><code class="language-python"># arr 6X3 返回3X3
In [131]: np.dot(arr.T, arr)
</code></pre>
<p>对于⾼维数组，transpose需要得到⼀个由轴编号组成的元组才能对这些轴进⾏转置（难）：</p>
<pre><code class="language-python">In [134]: arr.transpose((1, 0, 2))
# 第⼀个轴被换成了第⼆个，第⼆个轴被换成了第⼀个，最后⼀个轴不变。
</code></pre>
<p>简单的转置可以使⽤.T，它其实就是进⾏轴对换⽽已。</p>
</li>
</ol>
<h1 id="二-通用函数快速的元素级数组函数">二、<strong>通⽤函数：快速的元素级数组函数</strong></h1>
<ol>
<li>
<p><strong>简介</strong></p>
<p>通⽤函数（即ufunc）是⼀种对ndarray中的数据执⾏元素级运算的函数。可以将其看做简单函数（接受⼀个或多个标量值，并产⽣⼀个或多个标量值）的⽮量化包装器。</p>
</li>
<li>
<p><strong>一元</strong></p>
<pre><code class="language-python"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.sqrt(arr)
np.exp(arr)
</code></pre>
<p>另外⼀些（如add或maximum）接受2个数组（因此也叫⼆元（binary）ufunc），并返回⼀个结果数组：</p>
</li>
<li>
<p><strong>二元</strong></p>
<pre><code class="language-python">In [141]: x = np.random.randn(8) 
In [142]: y = np.random.randn(8)

In [145]: np.maximum(x, y)
Out[145]: 
array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,-0.6605])
</code></pre>
<p>这⾥，numpy.maximum计算了x和y中元素级别最⼤的元素。</p>
</li>
<li>
<p><strong>多返回值</strong></p>
<p>虽然并不常⻅，但有些ufunc的确可以返回多个数组。modf就是⼀个例⼦，它是Python内置函数divmod的⽮量化版本，它会返回浮点数数组的⼩数和整数部分：</p>
<pre><code class="language-python">In [148]: remainder, whole_part = np.modf(arr)
</code></pre>
</li>
<li>
<p><strong>ufunc详细表格</strong></p>
<p>Ufuncs可以接受⼀个<strong>out</strong>可选参数，这样就能在数组原地进⾏操作：</p>
<figure data-type="image" tabindex="7"><img src="https://dong1iu.github.io/post-images/1623039600020.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://dong1iu.github.io/post-images/1623039604252.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://dong1iu.github.io/post-images/1623039611235.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://dong1iu.github.io/post-images/1623039615617.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://dong1iu.github.io/post-images/1623039619902.png" alt="" loading="lazy"></figure>
</li>
</ol>
<h1 id="三-利用数组进行数据处理">三、<strong>利⽤数组进⾏数据处理</strong></h1>
<ol>
<li>
<p>INTRO</p>
<p>计算函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{x^2+y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2821659999999999em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578340000000001em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.917834em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2821659999999999em;"><span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-python">In [158]: z = np.sqrt(xs ** 2 + ys ** 2)
</code></pre>
</li>
<li>
<p><strong>将条件逻辑表述为数组运算</strong><br>
<strong>numpy.where</strong>函数是三元表达式x if condition else y的⽮量化版本。假设我们有⼀个布尔数组和两个值数组：</p>
<pre><code class="language-python">In [165]: xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
In [166]: yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
In [167]: cond = np.array([True, False, True, True, False])
</code></pre>
<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<pre><code class="language-python">In [168]: result = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]
</code></pre>
<p>问题。第⼀，它对⼤数组的处理速度不是很快（因为所有⼯作都是由纯Python完成的）。第⼆，⽆法⽤于多维数组。若使⽤np.where，则可以将该功能写得⾮常简洁：</p>
<pre><code class="language-python">In [170]: result = np.where(cond, xarr, yarr)
In [171]: result
Out[171]: array([ 1.1,  2.2,  1.3,  1.4,  2.5])
</code></pre>
<p>np.where的第⼆个和第三个参数不必是数组，它们都可以是标量值。在数据分析⼯作中，where通常⽤于根据另⼀个数组⽽产⽣⼀个新的数组。</p>
<p>假设有⼀个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利⽤np.where，则会⾮常简单</p>
<pre><code> ```python
 In [175]: np.where(arr &gt; 0, 2, -2)
 ```
</code></pre>
</li>
<li>
<p><strong>数学统计方法</strong></p>
<p>可以通过数组上的⼀组数学函数对整个数组或某个轴向的数据进⾏统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例⽅法调⽤，也可以当做顶级NumPy函数使⽤。</p>
<pre><code class="language-python">In [179]: arr.mean()
In [180]: np.mean(arr)
</code></pre>
<p>mean和sum这类的函数可以接受⼀个axis选项参数，⽤于计算该轴向上的统计值，最终结果是⼀个少⼀维的数组：</p>
<pre><code class="language-python">In [182]: arr.mean(axis=1)
# 沿着axis 1的方向，即加总一行中的每一列
Out[182]: array([ 1.022 ,  0.1875, -0.502 , -0.0881,  0.3611])
</code></pre>
<p>这⾥，arr.mean(1)是“计算⾏的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>其他如cumsum和cumprod之类的⽅法则不聚合，⽽是产⽣⼀个由中间结果组成的数组：（累加和累乘）</p>
</li>
<li>
<p><strong>基本数组统计方法</strong></p>
<figure data-type="image" tabindex="12"><img src="https://dong1iu.github.io/post-images/1623039628752.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://dong1iu.github.io/post-images/1623039633485.png" alt="" loading="lazy"></figure>
</li>
<li>
<p><strong>用于布尔型数组的办法</strong></p>
<p>在上⾯这些⽅法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被⽤来对布尔型数组中的True值计数：</p>
<pre><code class="language-python">(arr &gt; 0).sum()
</code></pre>
<p>另外还有两个⽅法any和all，它们对布尔型数组⾮常有⽤。any⽤于测试数组中是否存在⼀个或多个True，⽽all则检查数组中所有值是否都是True：</p>
<pre><code class="language-python">In [192]: bools = np.array([False, False, True, False])
In [193]: bools.any()
Out[193]: True
In [194]: bools.all()
Out[194]: False
</code></pre>
<p>这两个⽅法也能⽤于⾮布尔型数组，所有⾮0元素将会被当做True。</p>
</li>
<li>
<p><strong>排序</strong></p>
<p>跟Python内置的列表类型⼀样，NumPy数组也可以通过sort⽅法<strong>就地</strong>排序：</p>
<pre><code class="language-python">In [195]: arr = np.random.randn(6)
In [196]: arr
Out[196]: array([ 0.6095, -0.4938,  1.24  , -0.1357,  1.43  , -0.8469])
In [197]: arr.sort()
In [198]: arr
Out[198]: array([-0.8469, -0.4938, -0.1357,  0.6095,  1.24  ,  1.43  ])
</code></pre>
<p>多维数组可以在任何⼀个轴向上进⾏排序，只需将轴编号传给sort即可：</p>
<pre><code class="language-python"># 每行排序
In [201]: arr.sort(1)
</code></pre>
<p><strong>顶级⽅法np.sort返回的是数组的已排序副本，⽽就地排序则会修改数组本身。</strong></p>
<p><strong>计算数组分位数</strong>最简单的办法是对其进⾏排序，然后选取特定位置的值：</p>
<pre><code class="language-python">In [205]: large_arr[int(0.05 * len(large_arr))] # 5% quantile Out[205]: -1.5311513550102103
</code></pre>
</li>
<li>
<p><strong>唯⼀化以及其它的集合逻辑</strong></p>
<p>最常⽤的可能要数np.unique，⽤于找出数组中的唯⼀值并返回已排序的结果：</p>
<pre><code class="language-python">np.unique(names)
</code></pre>
<p>函数np.in1d⽤于测试⼀个数组中的值在另⼀个数组中的成员资格，返回⼀个布尔型数组：</p>
<pre><code class="language-python">In [211]: values = np.array([6, 0, 0, 3, 2, 5, 6])
In [212]: np.in1d(values, [2, 3, 6])
Out[212]: array([ True, False, False,  True,  True, False,  True], dtype=bool)
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://dong1iu.github.io/post-images/1623039647900.png" alt="" loading="lazy"></figure>
</li>
<li>
<p><strong>线性代数</strong></p>
<p>矩阵乘法x.dot(y)等价于np.dot(x, y)</p>
<p>⼀个⼆维数组跟⼀个⼤⼩合适的⼀维数组的矩阵点积运算之后将会得到⼀个⼀维数组：</p>
<pre><code class="language-python">In [223]: x = np.array([[1., 2., 3.], [4., 5., 6.]])
In [229]: np.dot(x, np.ones(3)) 
Out[229]: array([  6.,  15.])
# 发生了自动转置
</code></pre>
<p>@符（类似Python 3.5）也可以⽤作中缀运算符，进⾏矩阵乘法：</p>
<pre><code class="language-python">In [230]: x @ np.ones(3) 
Out[230]: array([  6.,  15.])
</code></pre>
<p>numpy.linalg中有⼀组标准的矩阵分解运算以及诸如求逆和⾏列式之类的东⻄。</p>
<figure data-type="image" tabindex="15"><img src="https://dong1iu.github.io/post-images/1623039655233.png" alt="" loading="lazy"></figure>
</li>
<li>
<p><strong>伪随机数⽣成</strong></p>
<p>numpy.random模块对Python内置的random进⾏了补充，增加了⼀些⽤于⾼效⽣成多种概率分布的样本值的函数。</p>
<p>你可以⽤normal来得到⼀个标准正态分布的4×4样本数组：</p>
<pre><code class="language-python">In [238]: samples = np.random.normal(size=(4, 4))
</code></pre>
<p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数⽣成器种⼦，在确定性的条件下⽣成的。你可以⽤NumPy的np.random.seed更改随机数⽣成种⼦：</p>
<pre><code class="language-python">In [244]: np.random.seed(1234)
</code></pre>
<p>numpy.random的数据⽣成函数使⽤了全局的随机种⼦。要避免全局状态，你可以使⽤numpy.random.RandomState，创建⼀个与其它隔离的随机数⽣成器：</p>
<pre><code class="language-python">In [245]: rng = np.random.RandomState(1234)
In [246]: rng.randn(10)
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="16"><img src="https://dong1iu.github.io/post-images/1623039661898.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://dong1iu.github.io/post-images/1623039665949.png" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#%E4%B8%80-ndarray">一、 ndarray</a></li>
<li><a href="#%E4%BA%8C-%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E5%BF%AB%E9%80%9F%E7%9A%84%E5%85%83%E7%B4%A0%E7%BA%A7%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0">二、<strong>通⽤函数：快速的元素级数组函数</strong></a></li>
<li><a href="#%E4%B8%89-%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">三、<strong>利⽤数组进⾏数据处理</strong></a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dong1iu.github.io/post/mac-zhong-duan-dai-li/">
              <h3 class="post-title">
                MAC终端代理
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dong1iu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
