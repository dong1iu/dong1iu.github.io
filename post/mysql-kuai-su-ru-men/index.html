<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MySQL快速入门 | 动动栋栋</title>
<link rel="shortcut icon" href="https://dong1iu.github.io/favicon.ico?v=1631503101257">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dong1iu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="MySQL快速入门 | 动动栋栋 - Atom Feed" href="https://dong1iu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="一、入门
（一）一些词汇
schema 模式 → 关于数据库和表的布局及特性的信息
datetype → 数据类型
column
row
primary key → 主键作为唯一标识，不得重复，非空
（二）主键和SQL语句
主键的习惯

不..." />
    <meta name="keywords" content="数据库" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dong1iu.github.io">
  <img class="avatar" src="https://dong1iu.github.io/images/avatar.png?v=1631503101257" alt="">
  </a>
  <h1 class="site-title">
    动动栋栋
  </h1>
  <p class="site-description">
    南风知我意 吹梦到西洲
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dong1iu.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              MySQL快速入门
            </h2>
            <div class="post-info">
              <span>
                2021-06-17
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://dong1iu.github.io/tag/rAn7xDm86/" class="post-tag">
                  # 数据库
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="一-入门">一、入门</h1>
<h2 id="一一些词汇">（一）一些词汇</h2>
<p>schema 模式 → 关于数据库和表的布局及特性的信息</p>
<p>datetype → 数据类型</p>
<p>column</p>
<p>row</p>
<p>primary key → 主键作为唯一标识，不得重复，非空</p>
<h2 id="二主键和sql语句">（二）主键和SQL语句</h2>
<p>主键的习惯</p>
<ol>
<li>不更改主键列的值</li>
<li>不重用主键的值</li>
<li>不在主键中使用可能会更改的值</li>
</ol>
<p>什么是SQL</p>
<p>SQL是数据库查询语言</p>
<h1 id="二-数据库的基本操作">二、数据库的基本操作</h1>
<h2 id="选择数据库">选择数据库</h2>
<p>语句： <code>use db;</code></p>
<p>返回值：无</p>
<h2 id="查看有哪些数据库">查看有哪些数据库</h2>
<p>语句：<code>show databases;</code></p>
<p>返回值：返回可用数据库的一个列表</p>
<h2 id="查看有哪些表">查看有哪些表</h2>
<p>语句：<code>show tables;</code></p>
<p>返回值：返回可用表的一个列表</p>
<h2 id="其他常用的语句">其他常用的语句</h2>
<ul>
<li><code>SHOW STATUS</code>，用于显示广泛的服务器状态信息;</li>
<li><code>SHOW CREATE DATABASE</code>和<code>SHOW CREATE TABLE</code>，分别用来显示创建特定数据库或表的MySQL语句;</li>
<li><code>SHOW GRANTS</code>，用来显示授予用户(所有用户或特定用户)的安全权限;</li>
<li><code>SHOW ERRORS</code>和<code>SHOW WARNINGS</code>，用来显示服务器错误或警告消息。</li>
</ul>
<h2 id="常见的关键词">常见的关键词</h2>
<p><code>DISTINCT</code>：去重</p>
<h1 id="三-排序">三、排序</h1>
<h2 id="单排序">单排序</h2>
<p><code>select * from student order by age;</code></p>
<h2 id="多排序">多排序</h2>
<p><code>select * from student order by age, major;</code></p>
<h2 id="升序和将序">升序和将序</h2>
<p><code>ORDER BY col1 DESC, col2</code></p>
<p>默认升序ASC，DESC降序</p>
<h2 id="注意">注意</h2>
<p>order by 不能处理A和a的排序问题，这个问题取决于数据库系统本身的设置</p>
<h1 id="四-数据过滤">四、数据过滤</h1>
<h2 id="where子句">WHERE子句</h2>
<p>常见操作符</p>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623897403344.png" alt="" loading="lazy"></figure>
<p>注意：</p>
<ol>
<li><strong>MySQL在执行匹配时默认不区分大小写</strong></li>
<li><code>BETWEEN AND</code> 两边都是闭区间</li>
<li>空值检查 → <code>IS NULL</code></li>
</ol>
<h2 id="操作符">操作符</h2>
<p>AND 操作符</p>
<p><code>WHERE ... AND WHERE ...</code></p>
<p>OR 操作符</p>
<p><code>WHERE ... OR WHERE ...</code></p>
<p>IN操作符</p>
<p><code>WHERE ... IN (1001, 1002)</code></p>
<p><code>IN</code>和<code>OR</code>的区别</p>
<p>其实<code>IN</code>操作符和<code>OR</code>完成的功能是一样的，但是<code>IN</code>操作符1.在语法上更简单、2.速度上更快、3.而且可以嵌套新的查询语句</p>
<p>NOT操作符</p>
<p>取反</p>
<h1 id="五-通配符">五、通配符</h1>
<h2 id="like操作符"><code>LIKE</code>操作符</h2>
<p>两个名词：通配符(wildcard)和搜索模式(search pattern)</p>
<p>search pattern一般由字面量和通配符组成</p>
<h2 id="常用的通配符">常用的通配符</h2>
<p><code>%</code> : 任意字符包括不匹配，<strong>但是注意%不能匹配NULL</strong></p>
<p><code>_</code> : 一个字符</p>
<h2 id="使用注意">使用注意</h2>
<ol>
<li>不要过度使用通配符，会导致查询的速度很慢</li>
<li>尽量不要将通配符放在匹配模式的前面，同样会导致速度相对变慢</li>
<li>注意不要错</li>
</ol>
<h1 id="六-正则表达式">六、正则表达式</h1>
<p>MySQL的正则表达式是通用的</p>
<h2 id="regexp关键字"><code>REGEXP</code>关键字</h2>
<pre><code class="language-sql">
SELECT * FROM student where item REGEXP '1000'
</code></pre>
<h2 id="or">OR</h2>
<p><code>REGEXP '1000|2000'</code></p>
<h2 id="转义">转义</h2>
<p>匹配一些特殊字符时，要在前面加<code>\\</code>，因为<code>\本身</code>也是特殊字符</p>
<p>比如匹配<code>.</code>，需要使用<code>\\.</code></p>
<h2 id="空白字符">空白字符</h2>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623897415622.png" alt="" loading="lazy"></figure>
<h2 id="匹配字符类">匹配字符类</h2>
<figure data-type="image" tabindex="3"><img src="https://dong1iu.github.io/post-images/1623897423942.png" alt="" loading="lazy"></figure>
<h2 id="匹配多个实体">匹配多个实体</h2>
<p>一个字符中可能有多个匹配的位置</p>
<p><a href="https://www.notion.so/48c62af6d57241beb93e01eec2d89564">重复元字符</a></p>
<h2 id="定位符">定位符</h2>
<p><a href="https://www.notion.so/9af2cc31b7ae477795ae854bb0fbae22">定位符表</a></p>
<p>例子</p>
<pre><code class="language-sql">SELECT * FROM student WHERE major REGEXP '^math'
</code></pre>
<h1 id="七-计算字段">七、计算字段</h1>
<h2 id="什么是计算字段">什么是计算字段</h2>
<p>在<code>SELECT</code>语句查询时计算的字段称为计算字段</p>
<p>字段（field）和列（column）是同一个意思</p>
<p>注意</p>
<p><strong>数据库服务器是知道<code>SELECT</code>语句中的字段是原生的字段，还是计算产生的字段</strong></p>
<h2 id="拼接字段">拼接字段</h2>
<p><code>Concat</code>函数</p>
<p>语法：CONCAT(field1, field2, ...)</p>
<p>RTrim函数</p>
<p>语法：RTrim(field)</p>
<p>含义：删除右边的空格</p>
<p>使用别名</p>
<p><code>AS</code>关键字</p>
<h2 id="执行计算">执行计算</h2>
<p><code>SELCET</code>时计算，如<code>SELECT order_id, price*amount AS expanded_price;</code></p>
<p>SQL支持<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></p>
<h1 id="八-数据处理函数">八、数据处理函数</h1>
<h2 id="文本处理函数">文本处理函数</h2>
<p>RTrim()</p>
<p>Upper()等</p>
<figure data-type="image" tabindex="4"><img src="https://dong1iu.github.io/post-images/1623897466003.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://dong1iu.github.io/post-images/1623897473866.png" alt="" loading="lazy"></figure>
<p>locate</p>
<p>语法：<code>locate(substr,str)</code></p>
<p>含义:返回子串 substr 在字符串 str 中第一次出现的位置</p>
<h2 id="日期处理">日期处理</h2>
<h3 id="1-日期格式">1. 日期格式</h3>
<p><a href="https://www.notion.so/e9a4a6a862964a028b63d4afab4bcbd7">MySQL中的日期格式</a></p>
<h3 id="2-时间处理">2. 时间处理</h3>
<p><a href="https://www.notion.so/072bfdba88cf454caeef87114be5e6f0">时间处理函数</a></p>
<h3 id="3间隔-interval">3.间隔 <code>INTERVAL</code></h3>
<p>语法：<code>INTERVAL expr unit</code></p>
<p>间隔值也用于各种时间函数，如<code>DATE_ADD</code>，<code>DATE_SUB</code>，<code>TIMESTAMPADD</code>和<code>TIMESTAMPDIFF</code></p>
<p>常用的使用</p>
<pre><code class="language-sql">set @dt=str_to_date('2021-6-10', '%Y-%m-%d');
select @dt - interval 1 day; # 返回2021-6-9
select @dt - interval 1 hour;
select @dt - interval 1 second;

# 复合
select @dt - interval '1 00:00:00' DAY_SECOND; # 返回2021-6-9
</code></pre>
<ul>
<li>
<p>完整的表格</p>
<p><a href="https://www.notion.so/99e78f03689843e1adfa606798ec5e14">interval可选unit</a></p>
</li>
</ul>
<h3 id="4-标准化">4. 标准化</h3>
<p><code>'2020-01-01 00:00:00'</code>→<code>'%Y-%m-%d %H:%i:%S'</code></p>
<h1 id="九-汇总数据">九、汇总数据</h1>
<h2 id="聚集函数">聚集函数</h2>
<p><code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code>、<code>COUNT()</code>、<code>SUM()</code></p>
<h2 id="聚集不同的值">聚集不同的值</h2>
<p><code>SELECT AVG(DISTINCT salary) FROM emp;</code></p>
<h2 id="组合聚集数">组合聚集数</h2>
<pre><code class="language-sql">
SELECT COUNT(*) AS num_items,
	MIN(prod_price) as price_min,
	MAX(prod_price) as price_max
FROM products
</code></pre>
<h1 id="十-分组">十、分组</h1>
<h2 id="创建分组">创建分组</h2>
<p>关键字<code>GROUP BY</code></p>
<p>注意</p>
<ol>
<li><strong>除了聚集语句外</strong>，SELECT语句中的所有列必须出现在GROUP BY子句中</li>
<li>如果<strong>分组列中具有NULL值</strong>，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组</li>
<li><strong>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</strong></li>
</ol>
<p>例子</p>
<pre><code class="language-sql">SELECT
	departmentId,
	avg( salary ) 
FROM
	employee 
GROUP BY
	departmentId
ORDER BY
	departmentId;
</code></pre>
<h2 id="过滤数据">过滤数据</h2>
<p>使用<code>HAVING</code>过滤分组</p>
<p>例子</p>
<pre><code class="language-sql">SELECT
	departmentId,
	avg( salary ) 
FROM
	employee 
GROUP BY
	departmentId 
HAVING
	avg( salary )&gt; 2000 
ORDER BY
	departmentId;
</code></pre>
<p><code>HAVING</code>和<code>WHERE</code>的区别</p>
<p><code>Where</code> 是一个约束声明，使用Where来约束来自数据库的数据，<code>Where</code>是在结果返回之前起作用的，且<code>Where</code>中不能使用聚合函数。</p>
<p><code>Having</code>是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在<code>Having</code>中可以使用聚合函数。</p>
<p>在执行顺序上的不同</p>
<p>要明白这一点，我们要明白SQL语句的执行顺序</p>
<pre><code>(8)SELECT (9)DISTINCT (11)&lt;Top Num&gt; &lt;select list&gt;(1)FROM left_table&lt;join_type&gt; JOIN &lt;right_table&gt;(2) ON &lt;join_condition&gt;(4)WHERE &lt;where_condition&gt;(5)GROUP BY &gt; &lt;group_by_list&gt;(6)WITH &lt;CUBE | RollUP&gt;(7)HAVING &lt;having_condition&gt;(10)ORDER BY &lt;order_by_list&gt;
</code></pre>
<p>补充连接表时，ON效率比WHERE比WHERE高，因为ON根据条件筛选数据后再生成临时表，而where是在生成临时表后再根据字段过滤数据</p>
<h1 id="十一-子查询">十一、子查询</h1>
<p>在<code>SELECT</code>语句中，子查询总是从内向外处理</p>
<h2 id="在where中使用子查询">在<code>where</code>中使用子查询</h2>
<pre><code class="language-sql">SELECT
	cust_id 
FROM
	orders 
WHERE
	order_num IN ( # 注意
	SELECT # 子查询
		order_num 
	FROM
		orderitems 
WHERE
	prod_id = 'TNT2')
</code></pre>
<p>列必须匹配 在WHERE子句中使用子查询(如这里所示)，应 该保证SELECT语句具有与WHERE子句中相同数目的列。<strong>通常， 子查询将返回单个列并且与单个列匹配</strong>，但如果需要也可以 使用多个列。</p>
<h2 id="在from中使用子查询">在<code>from</code>中使用子查询</h2>
<pre><code class="language-sql">select name, id
from (
	select * from student where age&gt;10
) tmp;
</code></pre>
<h2 id="在select中的子查询作为计算字段的子查询">在<code>select</code>中的子查询，作为计算字段的子查询</h2>
<p>该查询是在逻辑上最难理解，也是实际使用中比较少使用的</p>
<p>例子</p>
<pre><code class="language-sql"># 作为计算字段的子查询
SELECT
	cust_name,
	cust_state,
	(
	SELECT
		count(*) 
	FROM
		orders 
	WHERE
		orders.cust_id = customers.cust_id 
	) AS orders 
FROM
	customers 
ORDER BY
	cust_name;
</code></pre>
<p>解释：因为子查询中的where依赖父查询的中的customers表，称为**相关子查询。**因此运行的时候，customer每取出一个新的cust_id，orders表就会按<code>where</code>约束得到一个新的汇总值。</p>
<p>注意：</p>
<p>使用作为计算字段的子查询是万不得已的选择，这样的查询方式在逻辑上不易理解，在排除错误时容易发生错误，而且计算的逻辑和SQL本身的逻辑违背</p>
<h1 id="十二-联结表-join">十二、联结表 JOIN</h1>
<p>主键和外键</p>
<p>主键是唯一标识一张表中唯一元素的</p>
<p>外键是引用其他表的某列，作为该表的某列的约束</p>
<h2 id="联结">联结</h2>
<p>注意联结本身不是物理存在而是数据库在查询时生成的临时表</p>
<p>创建联结的两种方式</p>
<ol>
<li>
<p>使用Where创建——sql92</p>
<pre><code class="language-sql">//SQL92
SELECT e.name, d,dname 
FROM emp e, dept d 
WHERE e.deptno = d.deptno and ...;
</code></pre>
</li>
<li>
<p>使用on创建——sql99</p>
<pre><code class="language-sql">SELECTe.name, d,dname 
FROM emp e join dept d 
ON e.deptno = d.deptno 
WHERE...;
</code></pre>
<p>多表联结时</p>
<pre><code class="language-sql">SELECT e.ename, d.name, s.grade 
from emp e 
join dept d # ！！！
on e.deptno = d.deptno 
join salgrade s # ！！！
on e.sal bewteen s.losal and s.hisal
</code></pre>
</li>
</ol>
<p>连接方式</p>
<ol>
<li>等值连接</li>
<li>区间连接</li>
</ol>
<p>内连接、外连接和全连接</p>
<p>解释：</p>
<p>内连接：只保留满足约束的联结</p>
<p>外连接：除了保留满足约束的部分，还会保留左（右）表中未在右（左）出现的行。</p>
<p>全连接：保留左右表中所有的未匹配的行，补空值。<strong>不常用</strong></p>
<p><strong>注意：区分内外连接的是 right和left关键词 不是inner和outer，可以缺省inner和outer</strong></p>
<p>例子</p>
<pre><code class="language-sql">SELECT e.name, d,dname 
from emp e 
left outer join dept d 
on e.deptno = d.deptno
</code></pre>
<p>两种方式的区别：</p>
<ol>
<li><code>on</code>比<code>where</code>高效</li>
<li><code>on</code>比<code>where</code>在结构上清晰</li>
</ol>
<p><strong>笛卡尔积</strong></p>
<p>不使用约束时的结果</p>
<h2 id="使用表别名">使用表别名</h2>
<h2 id="使用不同类型的联结">使用不同类型的联结</h2>
<h3 id="自联结">自联结</h3>
<p><code>from</code>后两个相同的表<code>join</code></p>
<pre><code class="language-sql">select e2.ename, e1.departmentId from 
employee e1 join employee e2 
on e1.departmentId = e2.departmentId
where e1.ename ='p1';
</code></pre>
<h3 id="自然联结">自然联结</h3>
<p>自然联结排除多次出现，使每个列只返回一次。系统不完成这项工作，由你自己完成它。</p>
<p>这一 般是通过对表使用通配符(SELECT *)，对所有其他表的列使用明确的子 集来完成的。</p>
<h1 id="十三-组合查询">十三、组合查询</h1>
<h2 id="union关键字"><code>UNION</code>关键字</h2>
<pre><code class="language-sql">(SELECT ...) # 查询1
UNION
(SELECT ...) # 查询2
</code></pre>
<p>规则</p>
<ol>
<li>由两个以上的<code>SELECT</code>子句组成</li>
<li>UNION两端的查询必须包含相同的列、表达式或函数（顺序不需要相同，MySQL会自动对齐）</li>
<li>数据类型必须兼容:类型不必完全相同。DBMS会自动隐式地转换格式</li>
</ol>
<h2 id="union-all关键字"><code>UNION ALL</code>关键字</h2>
<p><code>UNION</code>会<strong>自动去重</strong>，加上<code>ALL</code>参数后不会自动去重</p>
<p>注意：<code>UNION</code>和多子句<code>Where</code>在一般情况下是可以替换的，具体的效率需要具体问题具体分析，但是<code>UNION ALL</code>是不可以通过多子句<code>Where</code>完成的</p>
<h2 id="union排序"><code>UNION</code>排序</h2>
<p>放在所有子句的最后</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%B8%80-%E5%85%A5%E9%97%A8">一、入门</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%80%E4%BA%9B%E8%AF%8D%E6%B1%87">（一）一些词汇</a></li>
<li><a href="#%E4%BA%8C%E4%B8%BB%E9%94%AE%E5%92%8Csql%E8%AF%AD%E5%8F%A5">（二）主键和SQL语句</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、数据库的基本操作</a>
<ul>
<li><a href="#%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93">选择数据库</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93">查看有哪些数据库</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A1%A8">查看有哪些表</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%AD%E5%8F%A5">其他常用的语句</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E8%AF%8D">常见的关键词</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%8E%92%E5%BA%8F">三、排序</a>
<ul>
<li><a href="#%E5%8D%95%E6%8E%92%E5%BA%8F">单排序</a></li>
<li><a href="#%E5%A4%9A%E6%8E%92%E5%BA%8F">多排序</a></li>
<li><a href="#%E5%8D%87%E5%BA%8F%E5%92%8C%E5%B0%86%E5%BA%8F">升序和将序</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F">注意</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4">四、数据过滤</a>
<ul>
<li><a href="#where%E5%AD%90%E5%8F%A5">WHERE子句</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6">操作符</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E9%80%9A%E9%85%8D%E7%AC%A6">五、通配符</a>
<ul>
<li><a href="#like%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>LIKE</code>操作符</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6">常用的通配符</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F">使用注意</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">六、正则表达式</a>
<ul>
<li><a href="#regexp%E5%85%B3%E9%94%AE%E5%AD%97"><code>REGEXP</code>关键字</a></li>
<li><a href="#or">OR</a></li>
<li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li>
<li><a href="#%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6">空白字符</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E7%B1%BB">匹配字符类</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BD%93">匹配多个实体</a></li>
<li><a href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83-%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">七、计算字段</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">什么是计算字段</a></li>
<li><a href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E6%AE%B5">拼接字段</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97">执行计算</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">八、数据处理函数</a>
<ul>
<li><a href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">文本处理函数</a></li>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86">日期处理</a>
<ul>
<li><a href="#1-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F">1. 日期格式</a></li>
<li><a href="#2-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86">2. 时间处理</a></li>
<li><a href="#3%E9%97%B4%E9%9A%94-interval">3.间隔 <code>INTERVAL</code></a></li>
<li><a href="#4-%E6%A0%87%E5%87%86%E5%8C%96">4. 标准化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE">九、汇总数据</a>
<ul>
<li><a href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0">聚集函数</a></li>
<li><a href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC">聚集不同的值</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E6%95%B0">组合聚集数</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81-%E5%88%86%E7%BB%84">十、分组</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84">创建分组</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE">过滤数据</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80-%E5%AD%90%E6%9F%A5%E8%AF%A2">十一、子查询</a>
<ul>
<li><a href="#%E5%9C%A8where%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2">在<code>where</code>中使用子查询</a></li>
<li><a href="#%E5%9C%A8from%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2">在<code>from</code>中使用子查询</a></li>
<li><a href="#%E5%9C%A8select%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2">在<code>select</code>中的子查询，作为计算字段的子查询</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8C-%E8%81%94%E7%BB%93%E8%A1%A8-join">十二、联结表 JOIN</a>
<ul>
<li><a href="#%E8%81%94%E7%BB%93">联结</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D">使用表别名</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%81%94%E7%BB%93">使用不同类型的联结</a>
<ul>
<li><a href="#%E8%87%AA%E8%81%94%E7%BB%93">自联结</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93">自然联结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%89-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2">十三、组合查询</a>
<ul>
<li><a href="#union%E5%85%B3%E9%94%AE%E5%AD%97"><code>UNION</code>关键字</a></li>
<li><a href="#union-all%E5%85%B3%E9%94%AE%E5%AD%97"><code>UNION ALL</code>关键字</a></li>
<li><a href="#union%E6%8E%92%E5%BA%8F"><code>UNION</code>排序</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dong1iu.github.io/post/git-jiao-cheng/">
              <h3 class="post-title">
                git教程
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dong1iu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
