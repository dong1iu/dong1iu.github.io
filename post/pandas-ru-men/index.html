<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pandas入门 | 动动栋栋</title>
<link rel="shortcut icon" href="https://dong1iu.github.io/favicon.ico?v=1623227951442">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://dong1iu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Pandas入门 | 动动栋栋 - Atom Feed" href="https://dong1iu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="介绍
pandas是基于NumPy数组构建的，特别是基于数组的函数和不使⽤for循环的数据处理。虽然pandas采⽤了⼤量的NumPy编码⻛格，但⼆者最⼤的不同是pandas是专⻔为处理表格和混杂数据设计的。
pandas的数据结构介绍
两..." />
    <meta name="keywords" content="python" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://dong1iu.github.io">
  <img class="avatar" src="https://dong1iu.github.io/images/avatar.png?v=1623227951442" alt="">
  </a>
  <h1 class="site-title">
    动动栋栋
  </h1>
  <p class="site-description">
    南风知我意 吹梦到西洲
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://dong1iu.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Pandas入门
            </h2>
            <div class="post-info">
              <span>
                2021-06-09
              </span>
              <span>
                9 min read
              </span>
              
                <a href="https://dong1iu.github.io/tag/EDcNg_R0it/" class="post-tag">
                  # python
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="介绍">介绍</h1>
<p>pandas是基于NumPy数组构建的，特别是基于数组的函数和不使⽤for循环的数据处理。虽然pandas采⽤了⼤量的NumPy编码⻛格，但⼆者最⼤的不同是pandas是专⻔为处理表格和混杂数据设计的。</p>
<h1 id="pandas的数据结构介绍">pandas的数据结构介绍</h1>
<p>两个主要数据结构：Series和DataFrame</p>
<h2 id="series"><strong>Series</strong></h2>
<p>Series是一种类似于一维数组的对象， 它由一组数据（各种NumPy数据类型）以及一组 与之相关的数据标签（即索引）组成。 仅由 一组数据即可产生最简单的Series</p>
<p>Series的字符串： 索引在左边 ， 值在右边 。 由干我们没有为数据指定索引 ， 于是会自动创建 一个0到N-1 (N为数据的长度）的整数型索引。 你可以通过Series的 values和index属性获取其数组表示形式和索引对象：</p>
<pre><code class="language-python">In [6]: obj.values 
Out[6]: array(( 4, 7, -5, 3]) 
In [7]: obj.index 
Out[7]: Int641ndex((o, 1, 2, 3])
</code></pre>
<p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p>
<p>NumPy数组运算（如根据布尔型数组进行过滤、 标抵乘法、 应用数学函数等）都会保留 索引和值之间的链接</p>
<p>还可以将Series看成是一个定长的有序字典， 因为它是索引值到数据值的一个映射。 它可以用在许多原本帣要字典参数的函数中：如果数据被存放在一个Python字典中 ， 也可以直接<strong>通过这个字典来创建Series</strong></p>
<p>Series最重要的一个功能是：<strong>它在算术运箕中会自动对齐不同索引的数据</strong></p>
<p><strong>Series对象本身及其索引都有一个name属性，obj和index都可以有name</strong></p>
<h2 id="dataframe"><strong>DataFrame</strong></h2>
<p>DataFrame是⼀个表格型的数据结构，它含有⼀组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有⾏索引也有列索引，它可以被看做由Series组成的字典（共⽤同⼀个索引）。</p>
<p>创建DataFrame<br>
<img src="https://dong1iu.github.io/post-images/1623226377660.png" alt="" loading="lazy"></p>
<p>最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典</p>
<p><strong>基本功能</strong></p>
<h1 id="reindex-重新索引">reindex 重新索引</h1>
<pre><code class="language-python">df.reindex(['a', 'b', 'c', 'd', 'e'])
	# 如果某个索引值当前不存在， 就引入缺失值：
df.reindex(['a', 'b', 'c', 'd', 'e'], fill_value=0)
</code></pre>
<p>插值处理</p>
<pre><code class="language-python">In [84]: obj3 = Series(['blue','purple','yellow'], index=[0, 2, 4])
In [85): obj3.reindex(range(6), method='ffill')
OUT[85]:
	0     blue
	1     blue
	2   purple
	3   purple
	4   yellow
	5   yellow
# 解释数值或日期按大小关系向前或向后插值
# 可带参数
# ffill  前向填充（或搬运）值
# bfill  后向填充（或撒运）值
</code></pre>
<p>对干DataFrame, re index可以修改（行）索引 、 列， 或两个都修改。默认索引行</p>
<p>使用columns关键字即可重新索引列，不存在的为用NAN填充</p>
<pre><code class="language-python">frame.reindex(columns=['a', 'b'])
</code></pre>
<p>同时对行和列进行重新索引 ， 而插值则只能桉行应用（即轴0)<br>
<img src="https://dong1iu.github.io/post-images/1623226387709.png" alt="" loading="lazy"></p>
<h1 id="drop-丢弃指定轴上的项">drop 丢弃指定轴上的项</h1>
<pre><code class="language-python"># 默认丢弃行index
df.drop(['index1', 'index2']， axis=0)

# 删除列
df.drop(['col1', 'col2'], axis=1)
</code></pre>
<h1 id="索引-选取和过滤">索引、选取和过滤</h1>
<p>利用标签的切片与普通切片不同， 其末端是包含的(inclusive)，即['b':'c']是包含‘c’的</p>
<h1 id="算术运算和数据对齐">算术运算和数据对齐</h1>
<p>自动对齐的数据中会用Nan填补缺失值</p>
<p>在算术方法中填充缺失值</p>
<pre><code class="language-python">df1.add(df2, fill_value=0)
</code></pre>
<p>其他算术方法</p>
<pre><code>sub div mul
</code></pre>
<h1 id="dataframe和series间的运算">DataFrame和Series间的运算</h1>
<p>类似广播原则</p>
<p>默认情况下，DataFrame和Series间的运算会将Series的索引匹配到列？？？</p>
<h1 id="函数应用和映射">函数应用和映射</h1>
<p>Numpy的ufuncs（元素级数组方法）设可用于pandas对象</p>
<pre><code class="language-python">np.abs(df)
</code></pre>
<p>也可将函数应用到各行或各列 形成一维数组上</p>
<pre><code class="language-python">f = lambda x: x.max() - x.min()
df.apply(f)  # 默认沿着行
df.apply(f, axis=1) # axis=1沿着列
</code></pre>
<p>可以返回由多个值组成的Series</p>
<pre><code class="language-python">def f(x):
	return Series([x.min(), x.max()], index=['min','max'])
In [165]: frame.apply(f)
OUT[165]:
			b    d     e
	min ... ...  ...
	max ... ...  ...
</code></pre>
<p>此外元素集的Python函数也可以，如对frame中各浮点值格式化...</p>
<pre><code class="language-python">format = lambda x:'%.2f' % x
</code></pre>
<h1 id="排序和排名sort_index">排序和排名(sort_index())</h1>
<pre><code class="language-python"># 按照index排序
df.sort_index()
# 按列排序
df.sort_index(axis=1)
	# 默认升序 降序使用
	ascending=False
 # 注意以上方法仅仅是对列名字排序，即对列的位置排序，并不涉及值计算
</code></pre>
<p>根据一个或多个列的值进行排序</p>
<pre><code class="language-python">df.sort_index(by=['a', 'b'])
</code></pre>
<p>使用rank排序</p>
<p>他会增加一列排名值，从1开始</p>
<pre><code class="language-python">ser1.rank()
</code></pre>
<p>也可以根据原数据中出现的顺序给出排名</p>
<pre><code class="language-python">ser1.rank(method='first')
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://dong1iu.github.io/post-images/1623226396342.png" alt="" loading="lazy"></figure>
<h1 id="带有重复值的轴索引is_unique">带有重复值的轴索引(is_unique）</h1>
<p>index是可以重复的 ，虽然许多pandas函数都要求index唯一，如reindex</p>
<p>查看是否唯一</p>
<pre><code class="language-python">df.index.is_unique()
</code></pre>
<h1 id="汇总和计算描述统计sum-meandiffsumsum">汇总和计算描述统计(sum, mean,diff,sumsum)</h1>
<p>Pandas对象拥有一组常用的数学和统计方法。用于从Series中提取单个值（如sum或mean) 或从DataFrame的行或列中提取一个Series。</p>
<p>汇总计算一般都默认对列做聚集 axis=0沿着行聚集</p>
<pre><code class="language-python">df.sum()  # 各列加总
df.sum(axis=1) # 各行加总

# NA值会被自动忽略不参与加总，使用skipna参数可以禁用功能，使得计算结果为NAN
df.mean(axis=1, skipna=False)

# 此外，还有level参数，如果轴是层次化索引
</code></pre>
<p>间接统计</p>
<pre><code class="language-python">df.idmax() #返回达到最大值得索引
</code></pre>
<p>累计型统计</p>
<pre><code class="language-python">df.cumsum()  # 累加
</code></pre>
<p>多次汇总统计</p>
<pre><code class="language-python">df.describe()
</code></pre>
<p>常用汇总统计方法<br>
<img src="https://dong1iu.github.io/post-images/1623226403691.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://dong1iu.github.io/post-images/1623226407708.png" alt="" loading="lazy"></figure>
<h1 id="相关系数和协方差corr-cov">相关系数和协方差(corr, cov)</h1>
<p>数据准备</p>
<pre><code class="language-python">import pandas.io.data as web  # 有错
all_data = {}
for  ticker in ['AAPL', 'IDM', 'MSFT', 'GOOG']:
	all_data[ticker] = web.get_data_yahoo(ticker, '1/1/2000', '1/1/2010')
price = DataFrame({tic: data['Adj Close'] for tic, data in all_data.iteritems()})
volume = DataFrame({tic: data['Volume'] for tic, data in all_data.iteritems()})
</code></pre>
<p>接下来计算价格的百分数变化：</p>
<pre><code class="language-python">returns = price.pct_change()
</code></pre>
<p>计算相关系数和协方差</p>
<pre><code class="language-python"># 两列数据返回相关系数
ser1.corr(ser2)
# 返回完整的相关系数矩阵
df.corr()
# 返回完整的协方差矩阵
df.corr()
</code></pre>
<p>corrwith 计算一个Series和另一个Series或DataFrame之间的相关系数</p>
<pre><code class="language-python">df.corrwith(volume)
</code></pre>
<h1 id="唯一值-值计数以及成员资格unique-uniquesort-value_counts-isin">唯一值、值计数以及成员资格(unique, unique.sort(), value_counts,, isin)</h1>
<p>得到Series中的唯一值</p>
<pre><code class="language-python">ser1.unique()
</code></pre>
<p>返回的唯一值是未排序的，如果需要排序，可以对结果再次排序</p>
<pre><code class="language-python">ser1.uniques.sort()
</code></pre>
<p>value_counts 计算Series中各值出现的频数</p>
<pre><code class="language-python">ser1.value.counts
</code></pre>
<p>value_counts方法是顶级pandas方法</p>
<pre><code class="language-python">pd.value_counts(ser1.values, sort=False)
</code></pre>
<p>isin 用于判断矢量化集合的成员资格，可以选取Series中或DataFrame列中数据的子集</p>
<pre><code class="language-python">ser.isin(['b', ['c']])
</code></pre>
<h1 id="处理缺失数据dropna-fillna-isnull-notnull">处理缺失数据(dropna fillna isnull notnull)</h1>
<p>NA处理方式<br>
<img src="https://dong1iu.github.io/post-images/1623226413841.png" alt="" loading="lazy"></p>
<h1 id="滤除缺失数据dropna">滤除缺失数据(dropna)</h1>
<p>简单丢弃 默认丢弃有缺失值的行</p>
<pre><code class="language-python">data.dropna()
data[data.dropna()]
</code></pre>
<p>复杂丢弃</p>
<pre><code class="language-python"># 只丢弃全为NA的那些行
df.dropnna(how='all')
# 只丢弃全为NA的那些列
df.dropna(how='all', axis=1)
# 保留至少有n个非NaN数据的行
df.dropna(thresh=n)
</code></pre>
<h1 id="填充缺失数据fillna">填充缺失数据(fillna)</h1>
<p>简单填充</p>
<pre><code class="language-python">df.fillna(0)
</code></pre>
<p>通过一个字典调用fillna，就可以现在不同列填充不同的值</p>
<pre><code class="language-python">In [251): df.fillna({1: 0.5, 3: -1})
</code></pre>
<p>fillna默认会返回新对象，使用inplace就地修改</p>
<p>fillna可以实现和reindex插值的功能</p>
<pre><code class="language-python"># 向前插值, limit=n
df.fillna(method='ffill', limit=n)
</code></pre>
<p>填入中位数或平均数</p>
<pre><code class="language-python">ser1.fillna(ser1.mean())

</code></pre>
<h1 id="层次化索引多个级别的索引">层次化索引(多个级别的索引)</h1>
<p>pandas的一项重要功能， 它使你能在一个轴上拥有多个（两个以上）索引级别。</p>
<pre><code class="language-python"># 数据准备
data = Series(np.rankdom.randn(10), index= [['a','a','a','b','b','b','c','c','d','d'],
	[1, 2, 3, 1, 2, 3, 1, 2, 2, 3]])
</code></pre>
<p>这就是带有Multilndex索引的Series的格式化输出形式。索引之间的＂间隔” 表示“直接使用上面的标签“</p>
<pre><code class="language-python">data.iloc[['b', 'd']]
data.iloc[['b':'d']]
# 在内层中索引
data[:, 2]
</code></pre>
<p>通过其unstack方法披重新安排到一个DataFrame中</p>
<pre><code class="language-python">data.unstack()
data.unstack().stack()
</code></pre>
<p>每个轴都可以有分层索引，columns也可以指定</p>
<p>各层都可以有名字，如果指定了名称，他们就会显示在控制台输出</p>
<pre><code class="language-python">df.index.names = ['key1', 'key2']
df.columns.names = ['key3', 'key4']
</code></pre>
<h1 id="重新分级排序swaplevel-sortlevel">重新分级排序(swaplevel, sortlevel)</h1>
<p>有时 ， 你需要重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序</p>
<pre><code class="language-python"># swaplevel接受两个级别编号或名称
frame.swaplevel('key1','key2')
</code></pre>
<p>sortlevel 交换级别时， 常常会用到</p>
<pre><code class="language-python">frame.sortlevel(1)
</code></pre>
<h1 id="根据级别汇总统计dfsumlevle">根据级别汇总统计(df.sum(levle=))</h1>
<p>许多对DataFrame和Series的描述和汇总统计都有一个level选项， 它用于指定在某条轴 上求和的级别。</p>
<pre><code class="language-python">frame.sum(level='key2')
</code></pre>
<h1 id="使用dataframe的列set_index-reset_index">使用DataFrame的列（set_index, reset_index）</h1>
<p>人们经常想要将DataFrame的一个或多个列当做行索引来用，或者将行索引变成DataFrame的列</p>
<pre><code class="language-python">df.set_index(['c', 'd'])
# 默认列会被移动到index
df.set_index(['c', 'd'], drop=False) # 保留

df.reset_index()  # 恢复所有
df.reset_index(['c', 'd'])  # 恢复指定
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
<li><a href="#pandas%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">pandas的数据结构介绍</a>
<ul>
<li><a href="#series"><strong>Series</strong></a></li>
<li><a href="#dataframe"><strong>DataFrame</strong></a></li>
</ul>
</li>
<li><a href="#reindex-%E9%87%8D%E6%96%B0%E7%B4%A2%E5%BC%95">reindex 重新索引</a></li>
<li><a href="#drop-%E4%B8%A2%E5%BC%83%E6%8C%87%E5%AE%9A%E8%BD%B4%E4%B8%8A%E7%9A%84%E9%A1%B9">drop 丢弃指定轴上的项</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95-%E9%80%89%E5%8F%96%E5%92%8C%E8%BF%87%E6%BB%A4">索引、选取和过滤</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90">算术运算和数据对齐</a></li>
<li><a href="#dataframe%E5%92%8Cseries%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97">DataFrame和Series间的运算</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%92%8C%E6%98%A0%E5%B0%84">函数应用和映射</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8E%92%E5%90%8Dsort_index">排序和排名(sort_index())</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC%E7%9A%84%E8%BD%B4%E7%B4%A2%E5%BC%95is_unique">带有重复值的轴索引(is_unique）</a></li>
<li><a href="#%E6%B1%87%E6%80%BB%E5%92%8C%E8%AE%A1%E7%AE%97%E6%8F%8F%E8%BF%B0%E7%BB%9F%E8%AE%A1sum-meandiffsumsum">汇总和计算描述统计(sum, mean,diff,sumsum)</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E5%92%8C%E5%8D%8F%E6%96%B9%E5%B7%AEcorr-cov">相关系数和协方差(corr, cov)</a></li>
<li><a href="#%E5%94%AF%E4%B8%80%E5%80%BC-%E5%80%BC%E8%AE%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BCunique-uniquesort-value_counts-isin">唯一值、值计数以及成员资格(unique, unique.sort(), value_counts,, isin)</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AEdropna-fillna-isnull-notnull">处理缺失数据(dropna fillna isnull notnull)</a></li>
<li><a href="#%E6%BB%A4%E9%99%A4%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AEdropna">滤除缺失数据(dropna)</a></li>
<li><a href="#%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AEfillna">填充缺失数据(fillna)</a></li>
<li><a href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E7%B4%A2%E5%BC%95%E5%A4%9A%E4%B8%AA%E7%BA%A7%E5%88%AB%E7%9A%84%E7%B4%A2%E5%BC%95">层次化索引(多个级别的索引)</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E5%88%86%E7%BA%A7%E6%8E%92%E5%BA%8Fswaplevel-sortlevel">重新分级排序(swaplevel, sortlevel)</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%BA%A7%E5%88%AB%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1dfsumlevle">根据级别汇总统计(df.sum(levle=))</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8dataframe%E7%9A%84%E5%88%97set_index-reset_index">使用DataFrame的列（set_index, reset_index）</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://dong1iu.github.io/post/mac-os-shi-jian-ji-qi-quan-li-bei-fen/">
              <h3 class="post-title">
                Mac OS 时间机器全力备份
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://dong1iu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
